var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// Runware/reconnect.ts
var require_reconnect = __commonJS({
  "Runware/reconnect.ts"(exports, module) {
    "use strict";
    var isWebSocket = (constructor) => constructor && constructor.CLOSING === 2;
    var isGlobalWebSocket = () => typeof WebSocket !== "undefined" && isWebSocket(WebSocket);
    var getDefaultOptions = () => ({
      constructor: isGlobalWebSocket() ? WebSocket : null,
      maxReconnectionDelay: 1e4,
      minReconnectionDelay: 1500,
      reconnectionDelayGrowFactor: 1.3,
      connectionTimeout: 4e3,
      maxRetries: Infinity,
      debug: false
    });
    var bypassProperty = (src, dst, name) => {
      Object.defineProperty(dst, name, {
        get: () => src[name],
        set: (value) => {
          src[name] = value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var initReconnectionDelay = (config) => config.minReconnectionDelay + Math.random() * config.minReconnectionDelay;
    var updateReconnectionDelay = (config, previousDelay) => {
      const newDelay = previousDelay * config.reconnectionDelayGrowFactor;
      return newDelay > config.maxReconnectionDelay ? config.maxReconnectionDelay : newDelay;
    };
    var LEVEL_0_EVENTS = ["onopen", "onclose", "onmessage", "onerror"];
    var reassignEventListeners = (ws, oldWs, listeners) => {
      Object.keys(listeners).forEach((type) => {
        listeners[type].forEach(([listener, options]) => {
          ws.addEventListener(type, listener, options);
        });
      });
      if (oldWs) {
        LEVEL_0_EVENTS.forEach((name) => {
          ws[name] = oldWs[name];
        });
      }
    };
    var ReconnectingWebsocket2 = function(url, protocols, options = {}) {
      let ws;
      let connectingTimeout;
      let reconnectDelay = 0;
      let retriesCount = 0;
      let shouldRetry = true;
      const listeners = {};
      if (!(this instanceof ReconnectingWebsocket2)) {
        throw new TypeError(
          "Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator"
        );
      }
      const config = getDefaultOptions();
      Object.keys(config).filter((key) => options.hasOwnProperty(key)).forEach((key) => config[key] = options[key]);
      if (!isWebSocket(config.constructor)) {
        throw new TypeError(
          "Invalid WebSocket constructor. Set `options.constructor`"
        );
      }
      const log = config.debug ? (...params) => console.log("RWS:", ...params) : () => {
      };
      const emitError = (code, msg) => setTimeout(() => {
        const err = new Error(msg);
        err.code = code;
        if (Array.isArray(listeners.error)) {
          listeners.error.forEach(([fn]) => fn(err));
        }
        if (ws.onerror) {
          ws.onerror(err);
        }
      }, 0);
      const handleClose = () => {
        log("close");
        retriesCount++;
        log("retries count:", retriesCount);
        if (retriesCount > config.maxRetries) {
          emitError("EHOSTDOWN", "Too many failed connection attempts");
          return;
        }
        if (!reconnectDelay) {
          reconnectDelay = initReconnectionDelay(config);
        } else {
          reconnectDelay = updateReconnectionDelay(config, reconnectDelay);
        }
        log("reconnectDelay:", reconnectDelay);
        if (shouldRetry) {
          setTimeout(connect, reconnectDelay);
        }
      };
      const connect = () => {
        log("connect");
        const oldWs = ws;
        ws = new config.constructor(url, protocols);
        connectingTimeout = setTimeout(() => {
          log("timeout");
          ws.close();
          emitError("ETIMEDOUT", "Connection timeout");
        }, config.connectionTimeout);
        log("bypass properties");
        for (let key in ws) {
          if (["addEventListener", "removeEventListener", "close", "send"].indexOf(
            key
          ) < 0) {
            bypassProperty(ws, this, key);
          }
        }
        ws.addEventListener("open", () => {
          clearTimeout(connectingTimeout);
          log("open");
          reconnectDelay = initReconnectionDelay(config);
          log("reconnectDelay:", reconnectDelay);
          retriesCount = 0;
        });
        ws.addEventListener("close", handleClose);
        reassignEventListeners(ws, oldWs, listeners);
      };
      log("init");
      connect();
      this.close = (code = 1e3, reason = "", { keepClosed = false, fastClose = true, delay: delay3 = 0 } = {}) => {
        if (delay3) {
          reconnectDelay = delay3;
        }
        shouldRetry = !keepClosed;
        ws.close(code, reason);
        if (fastClose) {
          const fakeCloseEvent = {
            code,
            reason,
            wasClean: true
          };
          handleClose();
          if (Array.isArray(listeners.close)) {
            listeners.close.forEach(([listener, options2]) => {
              listener(fakeCloseEvent);
              ws.removeEventListener("close", listener, options2);
            });
          }
          if (ws.onclose) {
            ws.onclose(fakeCloseEvent);
            ws.onclose = null;
          }
        }
      };
      this.send = (data) => {
        ws.send(data);
      };
      this.addEventListener = (type, listener, options2) => {
        if (Array.isArray(listeners[type])) {
          if (!listeners[type].some(([l]) => l === listener)) {
            listeners[type].push([listener, options2]);
          }
        } else {
          listeners[type] = [[listener, options2]];
        }
        ws.addEventListener(type, listener, options2);
      };
      this.removeEventListener = (type, listener, options2) => {
        if (Array.isArray(listeners[type])) {
          listeners[type] = listeners[type].filter(([l]) => l !== listener);
        }
        ws.removeEventListener(type, listener, options2);
      };
    };
    module.exports = ReconnectingWebsocket2;
  }
});

// Runware/types.ts
var Environment = /* @__PURE__ */ ((Environment2) => {
  Environment2["PRODUCTION"] = "PRODUCTION";
  Environment2["DEVELOPMENT"] = "DEVELOPMENT";
  Environment2["TEST"] = "TEST";
  return Environment2;
})(Environment || {});
var SdkType = /* @__PURE__ */ ((SdkType2) => {
  SdkType2["CLIENT"] = "CLIENT";
  SdkType2["SERVER"] = "SERVER";
  return SdkType2;
})(SdkType || {});
var ETaskType = /* @__PURE__ */ ((ETaskType2) => {
  ETaskType2["IMAGE_INFERENCE"] = "imageInference";
  ETaskType2["IMAGE_UPLOAD"] = "imageUpload";
  ETaskType2["IMAGE_UPSCALE"] = "imageUpscale";
  ETaskType2["IMAGE_BACKGROUND_REMOVAL"] = "imageBackgroundRemoval";
  ETaskType2["IMAGE_CAPTION"] = "imageCaption";
  ETaskType2["IMAGE_CONTROL_NET_PRE_PROCESS"] = "imageControlNetPreProcess";
  ETaskType2["PROMPT_ENHANCE"] = "promptEnhance";
  ETaskType2["AUTHENTICATION"] = "authentication";
  return ETaskType2;
})(ETaskType || {});
var EControlMode = /* @__PURE__ */ ((EControlMode2) => {
  EControlMode2["BALANCED"] = "balanced";
  EControlMode2["PROMPT"] = "prompt";
  EControlMode2["CONTROL_NET"] = "controlnet";
  return EControlMode2;
})(EControlMode || {});
var EPreProcessorGroup = /* @__PURE__ */ ((EPreProcessorGroup2) => {
  EPreProcessorGroup2["canny"] = "canny";
  EPreProcessorGroup2["depth"] = "depth";
  EPreProcessorGroup2["mlsd"] = "mlsd";
  EPreProcessorGroup2["normalbae"] = "normalbae";
  EPreProcessorGroup2["openpose"] = "openpose";
  EPreProcessorGroup2["tile"] = "tile";
  EPreProcessorGroup2["seg"] = "seg";
  EPreProcessorGroup2["lineart"] = "lineart";
  EPreProcessorGroup2["lineart_anime"] = "lineart_anime";
  EPreProcessorGroup2["shuffle"] = "shuffle";
  EPreProcessorGroup2["scribble"] = "scribble";
  EPreProcessorGroup2["softedge"] = "softedge";
  return EPreProcessorGroup2;
})(EPreProcessorGroup || {});
var EPreProcessor = /* @__PURE__ */ ((EPreProcessor2) => {
  EPreProcessor2["canny"] = "canny";
  EPreProcessor2["depth_leres"] = "depth_leres";
  EPreProcessor2["depth_midas"] = "depth_midas";
  EPreProcessor2["depth_zoe"] = "depth_zoe";
  EPreProcessor2["inpaint_global_harmonious"] = "inpaint_global_harmonious";
  EPreProcessor2["lineart_anime"] = "lineart_anime";
  EPreProcessor2["lineart_coarse"] = "lineart_coarse";
  EPreProcessor2["lineart_realistic"] = "lineart_realistic";
  EPreProcessor2["lineart_standard"] = "lineart_standard";
  EPreProcessor2["mlsd"] = "mlsd";
  EPreProcessor2["normal_bae"] = "normal_bae";
  EPreProcessor2["scribble_hed"] = "scribble_hed";
  EPreProcessor2["scribble_pidinet"] = "scribble_pidinet";
  EPreProcessor2["seg_ofade20k"] = "seg_ofade20k";
  EPreProcessor2["seg_ofcoco"] = "seg_ofcoco";
  EPreProcessor2["seg_ufade20k"] = "seg_ufade20k";
  EPreProcessor2["shuffle"] = "shuffle";
  EPreProcessor2["softedge_hed"] = "softedge_hed";
  EPreProcessor2["softedge_hedsafe"] = "softedge_hedsafe";
  EPreProcessor2["softedge_pidinet"] = "softedge_pidinet";
  EPreProcessor2["softedge_pidisafe"] = "softedge_pidisafe";
  EPreProcessor2["tile_gaussian"] = "tile_gaussian";
  EPreProcessor2["openpose"] = "openpose";
  EPreProcessor2["openpose_face"] = "openpose_face";
  EPreProcessor2["openpose_faceonly"] = "openpose_faceonly";
  EPreProcessor2["openpose_full"] = "openpose_full";
  EPreProcessor2["openpose_hand"] = "openpose_hand";
  return EPreProcessor2;
})(EPreProcessor || {});
var EOpenPosePreProcessor = /* @__PURE__ */ ((EOpenPosePreProcessor2) => {
  EOpenPosePreProcessor2["openpose"] = "openpose";
  EOpenPosePreProcessor2["openpose_face"] = "openpose_face";
  EOpenPosePreProcessor2["openpose_faceonly"] = "openpose_faceonly";
  EOpenPosePreProcessor2["openpose_full"] = "openpose_full";
  EOpenPosePreProcessor2["openpose_hand"] = "openpose_hand";
  return EOpenPosePreProcessor2;
})(EOpenPosePreProcessor || {});

// Runware/utils.ts
import { v4 as uuidv4, validate as validateUUID } from "uuid";
var TIMEOUT_DURATION = 6e4;
var MINIMUM_TIMEOUT_DURATION = 1e3;
var POLLING_INTERVAL = 100;
var BASE_RUNWARE_URLS = {
  ["PRODUCTION" /* PRODUCTION */]: "wss://ws-api.runware.ai/v1",
  ["TEST" /* TEST */]: "ws://localhost:8080"
};
var removeFromAray = (col, targetElem) => {
  if (col == null) {
    return;
  }
  let i = col.indexOf(targetElem);
  if (i === -1) {
    return;
  }
  col.splice(i, 1);
};
var getIntervalWithPromise = (callback, {
  debugKey = "debugKey",
  timeoutDuration = TIMEOUT_DURATION,
  shouldThrowError = true
}) => {
  timeoutDuration = timeoutDuration < MINIMUM_TIMEOUT_DURATION ? MINIMUM_TIMEOUT_DURATION : timeoutDuration;
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      if (intervalId) {
        clearInterval(intervalId);
        if (shouldThrowError) {
          reject(`Response could not be received from server for ${debugKey}`);
        }
      }
      clearTimeout(timeoutId);
    }, timeoutDuration);
    let intervalId = setInterval(async () => {
      const shouldClear = callback({ resolve, reject, intervalId });
      if (shouldClear) {
        clearInterval(intervalId);
        clearTimeout(timeoutId);
      }
    }, POLLING_INTERVAL);
  });
};
var fileToBase64 = (file) => new Promise((resolve) => {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = function() {
    resolve(reader.result);
  };
});
var getUUID = () => uuidv4();
var isValidUUID = (uuid) => validateUUID(uuid);
var accessDeepObject = ({
  key,
  data,
  useZero = true,
  shouldReturnString = false
}) => {
  const splittedKeys = key.split(/\.|\[/).map((key2) => key2.replace(/\]$/, ""));
  const value = splittedKeys.reduce((acc, curr) => {
    var _a, _b;
    const returnZero = useZero ? 0 : void 0;
    const currentValue = acc == null ? void 0 : acc[curr];
    if (!currentValue) {
      return returnZero;
    }
    if (Array.isArray(currentValue) && /^\d+$/.test(curr)) {
      const index = parseInt(curr, 10);
      if (index >= 0 && index < currentValue.length) {
        return acc[curr] = currentValue[index];
      } else {
        return (_a = acc[curr]) != null ? _a : returnZero;
      }
    } else {
      return (_b = acc[curr]) != null ? _b : returnZero;
    }
  }, data || {});
  return value != null ? value : {};
};
var delay = (time, milliseconds = 1e3) => {
  return new Promise((resolve) => setTimeout(resolve, time * milliseconds));
};
var removeListener = (listeners, listener) => {
  return listeners.filter((lis) => lis.key !== listener.key);
};
var evaluateNonTrue = ({
  key,
  value
}) => {
  if (!!value || value === 0 || value === false) {
    return { [key]: value };
  } else {
    return {};
  }
};

// Runware/async-retry.ts
var asyncRetry = async (apiCall, options = {}) => {
  var _a;
  const { delayInSeconds = 1, callback } = options;
  let maxRetries = (_a = options.maxRetries) != null ? _a : 1;
  while (maxRetries) {
    try {
      const result = await apiCall();
      return result;
    } catch (error) {
      callback == null ? void 0 : callback();
      maxRetries--;
      if (maxRetries > 0) {
        await delay(delayInSeconds);
        await asyncRetry(apiCall, __spreadProps(__spreadValues({}, options), { maxRetries }));
      } else {
        throw error;
      }
    }
  }
};

// Runware/Runware-base.ts
var RunwareBase = class {
  constructor({
    apiKey,
    url = BASE_RUNWARE_URLS.PRODUCTION,
    shouldReconnect = true,
    globalMaxRetries = 2,
    timeoutDuration = TIMEOUT_DURATION
  }) {
    this._listeners = [];
    // _globalMessages: any[] = [];
    this._globalMessages = {};
    this._globalImages = [];
    this.isWebsocketReadyState = () => {
      var _a;
      return ((_a = this._ws) == null ? void 0 : _a.readyState) === 1;
    };
    // We moving to an array format, it make sense to consolidate all request to an array here
    this.send = (msg) => {
      this._ws.send(JSON.stringify([msg]));
    };
    this.uploadImage = async (file) => {
      try {
        return await asyncRetry(async () => {
          const taskUUID = getUUID();
          if (typeof file === "string" && isValidUUID(file)) {
            return {
              imageURL: file,
              imageUUID: file,
              taskUUID,
              taskType: "imageUpload" /* IMAGE_UPLOAD */
            };
          }
          const imageBase64 = typeof file === "string" ? file : await fileToBase64(file);
          return {
            imageURL: imageBase64,
            imageUUID: imageBase64,
            taskUUID,
            taskType: "imageUpload" /* IMAGE_UPLOAD */
          };
        });
      } catch (e) {
        throw e;
      }
    };
    this.controlNetPreProcess = async ({
      inputImage,
      preProcessor,
      height,
      width,
      outputType,
      outputFormat,
      highThresholdCanny,
      lowThresholdCanny,
      includeHandsAndFaceOpenPose,
      includeCost,
      customTaskUUID,
      retry
    }) => {
      const totalRetry = retry || this._globalMaxRetries;
      let lis = void 0;
      try {
        return await asyncRetry(
          async () => {
            await this.ensureConnection();
            const image = await this.uploadImage(inputImage);
            if (!(image == null ? void 0 : image.imageUUID))
              return null;
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
              inputImage: image.imageUUID,
              taskType: "imageControlNetPreProcess" /* IMAGE_CONTROL_NET_PRE_PROCESS */,
              taskUUID,
              preProcessor
            }, evaluateNonTrue({ key: "height", value: height })), evaluateNonTrue({ key: "width", value: width })), evaluateNonTrue({ key: "outputType", value: outputType })), evaluateNonTrue({ key: "outputFormat", value: outputFormat })), evaluateNonTrue({ key: "includeCost", value: includeCost })), evaluateNonTrue({
              key: "highThresholdCanny",
              value: highThresholdCanny
            })), evaluateNonTrue({
              key: "lowThresholdCanny",
              value: lowThresholdCanny
            })), evaluateNonTrue({
              key: "includeHandsAndFaceOpenPose",
              value: includeHandsAndFaceOpenPose
            })));
            lis = this.globalListener({
              taskUUID
            });
            const guideImage = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const uploadedImage = this.getSingleMessage({
                  taskUUID
                });
                if (!uploadedImage)
                  return;
                if (uploadedImage == null ? void 0 : uploadedImage.error) {
                  reject(uploadedImage);
                  return true;
                }
                if (uploadedImage) {
                  resolve(uploadedImage);
                  return true;
                }
              },
              {
                debugKey: "unprocessed-image",
                timeoutDuration: this._timeoutDuration
              }
            );
            lis.destroy();
            return guideImage;
          },
          {
            maxRetries: totalRetry,
            callback: () => {
              lis == null ? void 0 : lis.destroy();
            }
          }
        );
      } catch (e) {
        throw e;
      }
    };
    this.requestImageToText = async ({
      inputImage,
      includeCost,
      customTaskUUID,
      retry
    }) => {
      const totalRetry = retry || this._globalMaxRetries;
      let lis = void 0;
      try {
        return await asyncRetry(
          async () => {
            await this.ensureConnection();
            const imageUploaded = inputImage ? await this.uploadImage(inputImage) : null;
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadValues({
              taskUUID,
              taskType: "imageCaption" /* IMAGE_CAPTION */,
              inputImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID
            }, evaluateNonTrue({ key: "includeCost", value: includeCost })));
            lis = this.globalListener({
              taskUUID
            });
            const response = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const newReverseClip = this.getSingleMessage({
                  taskUUID
                });
                if (!newReverseClip)
                  return;
                if (newReverseClip == null ? void 0 : newReverseClip.error) {
                  reject(newReverseClip);
                  return true;
                }
                if (newReverseClip) {
                  delete this._globalMessages[taskUUID];
                  resolve(newReverseClip);
                  return true;
                }
              },
              {
                debugKey: "remove-image-background",
                timeoutDuration: this._timeoutDuration
              }
            );
            lis.destroy();
            return response;
          },
          {
            maxRetries: totalRetry,
            callback: () => {
              lis == null ? void 0 : lis.destroy();
            }
          }
        );
      } catch (e) {
        throw e;
      }
    };
    this.removeImageBackground = async ({
      inputImage,
      outputType,
      outputFormat,
      rgba,
      postProcessMask,
      returnOnlyMask,
      alphaMatting,
      alphaMattingForegroundThreshold,
      alphaMattingBackgroundThreshold,
      alphaMattingErodeSize,
      includeCost,
      customTaskUUID,
      retry
    }) => {
      const totalRetry = retry || this._globalMaxRetries;
      let lis = void 0;
      try {
        return await asyncRetry(
          async () => {
            await this.ensureConnection();
            const imageUploaded = inputImage ? await this.uploadImage(inputImage) : null;
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
              taskType: "imageBackgroundRemoval" /* IMAGE_BACKGROUND_REMOVAL */,
              taskUUID,
              inputImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID
            }, evaluateNonTrue({ key: "rgba", value: rgba })), evaluateNonTrue({
              key: "postProcessMask",
              value: postProcessMask
            })), evaluateNonTrue({
              key: "returnOnlyMask",
              value: returnOnlyMask
            })), evaluateNonTrue({ key: "alphaMatting", value: alphaMatting })), evaluateNonTrue({ key: "includeCost", value: includeCost })), evaluateNonTrue({
              key: "alphaMattingForegroundThreshold",
              value: alphaMattingForegroundThreshold
            })), evaluateNonTrue({
              key: "alphaMattingBackgroundThreshold",
              value: alphaMattingBackgroundThreshold
            })), evaluateNonTrue({
              key: "alphaMattingErodeSize",
              value: alphaMattingErodeSize
            })), evaluateNonTrue({ key: "outputType", value: outputType })), evaluateNonTrue({ key: "outputFormat", value: outputFormat })));
            lis = this.globalListener({
              taskUUID
            });
            const response = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const newRemoveBackground = this.getSingleMessage({ taskUUID });
                if (!newRemoveBackground)
                  return;
                if (newRemoveBackground == null ? void 0 : newRemoveBackground.error) {
                  reject(newRemoveBackground);
                  return true;
                }
                if (newRemoveBackground) {
                  delete this._globalMessages[taskUUID];
                  resolve(newRemoveBackground);
                  return true;
                }
              },
              {
                debugKey: "remove-image-background",
                timeoutDuration: this._timeoutDuration
              }
            );
            lis.destroy();
            return response;
          },
          {
            maxRetries: totalRetry,
            callback: () => {
              lis == null ? void 0 : lis.destroy();
            }
          }
        );
      } catch (e) {
        throw e;
      }
    };
    this.upscaleGan = async ({
      inputImage,
      upscaleFactor,
      outputType,
      outputFormat,
      includeCost,
      customTaskUUID,
      retry
    }) => {
      const totalRetry = retry || this._globalMaxRetries;
      let lis = void 0;
      try {
        return await asyncRetry(
          async () => {
            await this.ensureConnection();
            let imageUploaded;
            imageUploaded = await this.uploadImage(inputImage);
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadValues(__spreadValues(__spreadValues({
              taskUUID,
              inputImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID,
              taskType: "imageUpscale" /* IMAGE_UPSCALE */,
              upscaleFactor
            }, evaluateNonTrue({ key: "includeCost", value: includeCost })), outputType ? { outputType } : {}), outputFormat ? { outputFormat } : {}));
            lis = this.globalListener({
              taskUUID
            });
            const response = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const newUpscaleGan = this.getSingleMessage({ taskUUID });
                if (!newUpscaleGan)
                  return;
                if (newUpscaleGan == null ? void 0 : newUpscaleGan.error) {
                  reject(newUpscaleGan);
                  return true;
                }
                if (newUpscaleGan) {
                  delete this._globalMessages[taskUUID];
                  resolve(newUpscaleGan);
                  return true;
                }
              },
              { debugKey: "upscale-gan", timeoutDuration: this._timeoutDuration }
            );
            lis.destroy();
            return response;
          },
          {
            maxRetries: totalRetry,
            callback: () => {
              lis == null ? void 0 : lis.destroy();
            }
          }
        );
      } catch (e) {
        throw e;
      }
    };
    this.enhancePrompt = async ({
      prompt,
      promptMaxLength = 380,
      promptVersions = 1,
      includeCost,
      customTaskUUID,
      retry
    }) => {
      const totalRetry = retry || this._globalMaxRetries;
      let lis = void 0;
      try {
        return await asyncRetry(
          async () => {
            await this.ensureConnection();
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadProps(__spreadValues({
              prompt,
              taskUUID,
              promptMaxLength,
              promptVersions
            }, evaluateNonTrue({ key: "includeCost", value: includeCost })), {
              taskType: "promptEnhance" /* PROMPT_ENHANCE */
            }));
            lis = this.globalListener({
              taskUUID
            });
            const response = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const reducedPrompt = this._globalMessages[taskUUID];
                if (reducedPrompt == null ? void 0 : reducedPrompt.error) {
                  reject(reducedPrompt);
                  return true;
                }
                if ((reducedPrompt == null ? void 0 : reducedPrompt.length) >= promptVersions) {
                  delete this._globalMessages[taskUUID];
                  resolve(reducedPrompt);
                  return true;
                }
              },
              {
                debugKey: "enhance-prompt",
                timeoutDuration: this._timeoutDuration
              }
            );
            lis.destroy();
            return response;
          },
          {
            maxRetries: totalRetry,
            callback: () => {
              lis == null ? void 0 : lis.destroy();
            }
          }
        );
      } catch (e) {
        throw e;
      }
    };
    this.getSingleMessage = ({ taskUUID }) => {
      var _a;
      const value = (_a = this._globalMessages[taskUUID]) == null ? void 0 : _a[0];
      const errorValue = this._globalMessages[taskUUID];
      if (!value && !errorValue)
        return null;
      return (errorValue == null ? void 0 : errorValue.error) ? errorValue : value;
    };
    this.disconnect = async () => {
      var _a, _b, _c, _d;
      (_b = (_a = this._ws) == null ? void 0 : _a.terminate) == null ? void 0 : _b.call(_a);
      (_d = (_c = this._ws) == null ? void 0 : _c.close) == null ? void 0 : _d.call(_c);
    };
    this.connected = () => this.isWebsocketReadyState() && !!this._connectionSessionUUID;
    this._apiKey = apiKey;
    this._url = url;
    this._sdkType = "CLIENT" /* CLIENT */;
    this._shouldReconnect = shouldReconnect;
    this._globalMaxRetries = globalMaxRetries;
    this._timeoutDuration = timeoutDuration;
  }
  static async initialize(props) {
    try {
      const instance = new this(props);
      await instance.ensureConnection();
      return instance;
    } catch (e) {
      throw e;
    }
  }
  // protected addListener({
  //   lis,
  //   check,
  // }: {
  //   lis: (v: any) => any;
  //   check: (v: any) => any;
  //   groupKey?: string;
  // }): { destroy: Function } {
  //   this._ws.onmessage = (e: any) => {
  //     const m = JSON.parse(e.data);
  //     if (m?.error) {
  //       lis(m);
  //     } else if (check(m)) {
  //       lis(m);
  //     }
  //   };
  //   return {
  //     destroy: () => {},
  //   };
  // }
  addListener({
    lis,
    // check,
    groupKey,
    taskUUID
  }) {
    const listener = (msg) => {
      var _a;
      const arrayMessage = Array.isArray(msg == null ? void 0 : msg.data) ? msg.data : [msg.data];
      const arrayErrors = Array.isArray(msg == null ? void 0 : msg.errors) ? msg.errors : [msg.errors];
      const filteredMessage = arrayMessage.filter(
        (v) => ((v == null ? void 0 : v.taskUUID) || (v == null ? void 0 : v.taskType)) === taskUUID
      );
      const filteredErrors = arrayErrors.filter(
        (v) => ((v == null ? void 0 : v.taskUUID) || (v == null ? void 0 : v.taskType)) === taskUUID
      );
      if (filteredErrors.length) {
        lis({ error: __spreadValues({}, (_a = arrayErrors[0]) != null ? _a : {}) });
        return;
      }
      if (filteredMessage.length) {
        lis({ [taskUUID]: arrayMessage });
        return;
      }
    };
    const groupListener = { key: getUUID(), listener, groupKey };
    this._listeners.push(groupListener);
    const destroy = () => {
      this._listeners = removeListener(this._listeners, groupListener);
    };
    return {
      destroy
    };
  }
  connect() {
    this._ws.onopen = (e) => {
      if (this._connectionSessionUUID) {
        this.send({
          taskType: "authentication" /* AUTHENTICATION */,
          apiKey: this._apiKey,
          connectionSessionUUID: this._connectionSessionUUID
        });
      } else {
        this.send({ apiKey: this._apiKey, taskType: "authentication" /* AUTHENTICATION */ });
      }
      this.addListener({
        taskUUID: "authentication" /* AUTHENTICATION */,
        lis: (m) => {
          var _a, _b;
          if (m == null ? void 0 : m.error) {
            this._invalidAPIkey = m;
            return;
          }
          this._connectionSessionUUID = (_b = (_a = m == null ? void 0 : m["authentication" /* AUTHENTICATION */]) == null ? void 0 : _a[0]) == null ? void 0 : _b.connectionSessionUUID;
          this._invalidAPIkey = void 0;
        }
      });
    };
    this._ws.onmessage = (e) => {
      var _a;
      const data = JSON.parse(e.data);
      for (const lis of this._listeners) {
        const result = (_a = lis == null ? void 0 : lis.listener) == null ? void 0 : _a.call(lis, data);
        if (result)
          return;
      }
    };
    this._ws.onclose = (e) => {
      if (this._invalidAPIkey) {
        return;
      }
    };
  }
  destroy(lis) {
    removeFromAray(this._listeners, lis);
  }
  listenToImages({
    onPartialImages,
    taskUUID,
    groupKey,
    positivePrompt,
    negativePrompt
  }) {
    return this.addListener({
      taskUUID,
      lis: (m) => {
        var _a, _b;
        let images = (_a = m == null ? void 0 : m[taskUUID]) == null ? void 0 : _a.filter(
          (img) => img.taskUUID === taskUUID
        );
        if (m.error) {
          onPartialImages == null ? void 0 : onPartialImages(images, (m == null ? void 0 : m.error) && m);
          this._globalError = m;
        } else {
          images = images.map((image) => __spreadProps(__spreadValues({}, image), {
            positivePrompt,
            negativePrompt
          }));
          onPartialImages == null ? void 0 : onPartialImages(images, (m == null ? void 0 : m.error) && m);
          if (this._sdkType === "CLIENT" /* CLIENT */) {
            this._globalImages = [
              ...this._globalImages,
              ...((_b = m == null ? void 0 : m[taskUUID]) != null ? _b : []).map((image) => __spreadProps(__spreadValues({}, image), {
                positivePrompt,
                negativePrompt
              }))
            ];
          } else {
            this._globalImages = [...this._globalImages, ...images];
          }
        }
      },
      groupKey
    });
  }
  globalListener({ taskUUID }) {
    return this.addListener({
      // check: (m) => {
      //   const value = accessDeepObject({
      //     key: responseKey,
      //     data: m,
      //     useZero: false,
      //   });
      //   return !!value;
      // },
      // check: responseKey,
      taskUUID,
      lis: (m) => {
        if (m.error) {
          this._globalMessages[taskUUID] = m;
          return;
        }
        const value = accessDeepObject({
          key: taskUUID,
          data: m,
          useZero: false
        });
        if (Array.isArray(value)) {
          value.forEach((v) => {
            var _a;
            this._globalMessages[v.taskUUID] = [
              ...(_a = this._globalMessages[v.taskUUID]) != null ? _a : [],
              v
            ];
          });
        } else {
          this._globalMessages[value.taskUUID] = value;
        }
      }
    });
  }
  async requestImages({
    outputType,
    outputFormat,
    uploadEndpoint,
    checkNsfw,
    positivePrompt,
    negativePrompt,
    seedImage,
    maskImage,
    strength,
    height,
    width,
    model,
    steps,
    scheduler,
    seed,
    CFGScale,
    clipSkip,
    usePromptWeighting,
    numberResults = 1,
    controlNet,
    lora,
    onPartialImages,
    includeCost,
    customTaskUUID,
    retry
  }) {
    let lis = void 0;
    let requestObject = void 0;
    let taskUUIDs = [];
    let retryCount = 0;
    const totalRetry = retry || this._globalMaxRetries;
    try {
      await this.ensureConnection();
      let seedImageUUID = null;
      let maskImageUUID = null;
      let controlNetData = [];
      if (seedImage) {
        const uploadedImage = await this.uploadImage(seedImage);
        if (!uploadedImage)
          return [];
        seedImageUUID = uploadedImage.imageUUID;
      }
      if (maskImage) {
        const uploadedMaskInitiator = await this.uploadImage(maskImage);
        if (!uploadedMaskInitiator)
          return [];
        maskImageUUID = uploadedMaskInitiator.imageUUID;
      }
      if (controlNet == null ? void 0 : controlNet.length) {
        for (let i = 0; i < controlNet.length; i++) {
          const controlData = controlNet[i];
          const {
            endStep,
            startStep,
            weight,
            guideImage,
            controlMode,
            startStepPercentage,
            endStepPercentage,
            model: controlNetModel
          } = controlData;
          const imageUploaded = guideImage ? await this.uploadImage(guideImage) : null;
          controlNetData.push(__spreadProps(__spreadValues(__spreadValues({
            guideImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID,
            model: controlNetModel,
            endStep,
            startStep,
            weight
          }, evaluateNonTrue({
            key: "startStepPercentage",
            value: startStepPercentage
          })), evaluateNonTrue({
            key: "endStepPercentage",
            value: endStepPercentage
          })), {
            controlMode: controlMode || "controlnet" /* CONTROL_NET */
          }));
        }
      }
      requestObject = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({
        taskType: "imageInference" /* IMAGE_INFERENCE */,
        model,
        positivePrompt
      }, negativePrompt ? { negativePrompt } : {}), height ? { height } : {}), width ? { width } : {}), {
        numberResults
      }), (lora == null ? void 0 : lora.length) ? { lora } : {}), outputType ? { outputType } : {}), outputFormat ? { outputFormat } : {}), uploadEndpoint ? { uploadEndpoint } : {}), evaluateNonTrue({ key: "checkNsfw", value: checkNsfw })), evaluateNonTrue({ key: "strength", value: strength })), evaluateNonTrue({ key: "CFGScale", value: CFGScale })), evaluateNonTrue({ key: "clipSkip", value: clipSkip })), evaluateNonTrue({
        key: "usePromptWeighting",
        value: usePromptWeighting
      })), evaluateNonTrue({ key: "steps", value: steps })), controlNetData.length ? { controlNet: controlNetData } : {}), seed ? { seed } : {}), scheduler ? { scheduler } : {}), evaluateNonTrue({ key: "includeCost", value: includeCost })), seedImageUUID ? { seedImage: seedImageUUID } : {}), maskImageUUID ? { maskImage: maskImageUUID } : {});
      return await asyncRetry(
        async () => {
          retryCount++;
          lis == null ? void 0 : lis.destroy();
          const imagesWithSimilarTask = this._globalImages.filter(
            (img) => taskUUIDs.includes(img.taskUUID)
          );
          const taskUUID = customTaskUUID || getUUID();
          taskUUIDs.push(taskUUID);
          const imageRemaining = numberResults - imagesWithSimilarTask.length;
          const newRequestObject = __spreadProps(__spreadValues({}, requestObject), {
            taskUUID,
            numberResults: imageRemaining
          });
          this.send(newRequestObject);
          lis = this.listenToImages({
            onPartialImages,
            taskUUID,
            groupKey: "REQUEST_IMAGES" /* REQUEST_IMAGES */,
            positivePrompt,
            negativePrompt
          });
          const promise = await this.getSimilarImages({
            taskUUID: taskUUIDs,
            numberResults,
            lis
          });
          lis.destroy();
          return promise;
        },
        {
          maxRetries: totalRetry,
          callback: () => {
            lis == null ? void 0 : lis.destroy();
          }
        }
      );
    } catch (e) {
      if (e.taskUUID) {
        throw e;
      }
      if (retryCount >= totalRetry) {
        return this.handleIncompleteImages({ taskUUIDs, error: e });
      }
    }
  }
  async ensureConnection() {
    var _a;
    let isConnected = this.connected();
    if (isConnected || this._url === BASE_RUNWARE_URLS.TEST)
      return;
    const retryInterval = 2e3;
    const pollingInterval = 200;
    try {
      if (this._invalidAPIkey)
        throw this._invalidAPIkey;
      return new Promise((resolve, reject) => {
        let retry = 0;
        const MAX_RETRY = 30;
        const SHOULD_RETRY = 30 / 2 === retry;
        let retryIntervalId;
        let pollingIntervalId;
        const clearAllIntervals = () => {
          clearInterval(retryIntervalId);
          clearInterval(pollingIntervalId);
        };
        if (this._sdkType === "SERVER" /* SERVER */) {
          retryIntervalId = setInterval(async () => {
            try {
              const hasConnected = this.connected();
              if (hasConnected) {
                clearAllIntervals();
                resolve(true);
              } else if (retry >= MAX_RETRY) {
                clearAllIntervals();
                reject(new Error("Retry timed out"));
              } else {
                if (SHOULD_RETRY) {
                  this.connect();
                }
                retry++;
              }
            } catch (error) {
              clearAllIntervals();
              reject(error);
            }
          }, retryInterval);
        }
        pollingIntervalId = setInterval(async () => {
          const hasConnected = this.connected();
          if (hasConnected) {
            clearAllIntervals();
            resolve(true);
            return;
          }
          if (!!this._invalidAPIkey) {
            clearAllIntervals();
            reject(this._invalidAPIkey);
            return;
          }
        }, pollingInterval);
      });
    } catch (e) {
      throw (_a = this._invalidAPIkey) != null ? _a : "Could not connect to server. Ensure your API key is correct";
    }
  }
  async getSimilarImages({
    taskUUID,
    numberResults,
    shouldThrowError,
    lis
  }) {
    return await getIntervalWithPromise(
      ({ resolve, reject, intervalId }) => {
        const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];
        const imagesWithSimilarTask = this._globalImages.filter(
          (img) => taskUUIDs.includes(img.taskUUID)
        );
        if (this._globalError) {
          const newData = this._globalError;
          this._globalError = void 0;
          clearInterval(intervalId);
          reject == null ? void 0 : reject(newData);
          return true;
        } else if (imagesWithSimilarTask.length >= numberResults) {
          clearInterval(intervalId);
          this._globalImages = this._globalImages.filter(
            (img) => !taskUUIDs.includes(img.taskUUID)
          );
          resolve([...imagesWithSimilarTask].slice(0, numberResults));
          return true;
        }
      },
      {
        debugKey: "getting images",
        shouldThrowError,
        timeoutDuration: this._timeoutDuration
      }
    );
  }
  handleIncompleteImages({
    taskUUIDs,
    error
  }) {
    const imagesWithSimilarTask = this._globalImages.filter(
      (img) => taskUUIDs.includes(img.taskUUID)
    );
    if (imagesWithSimilarTask.length > 1) {
      this._globalImages = this._globalImages.filter(
        (img) => !taskUUIDs.includes(img.taskUUID)
      );
      return imagesWithSimilarTask;
    } else {
      throw error;
    }
  }
  //end of data
};

// Runware/Runware-client.ts
var import_reconnect = __toESM(require_reconnect());
var RunwareClient = class extends RunwareBase {
  constructor(props) {
    const _a = props, { shouldReconnect } = _a, rest = __objRest(_a, ["shouldReconnect"]);
    super(rest);
    this._ws = new import_reconnect.default(
      this._url
    );
    this.connect();
  }
};

// Runware/Runware-server.ts
import WebSocket2 from "ws";
var RunwareServer = class extends RunwareBase {
  constructor(props) {
    super(props);
    this._instantiated = false;
    this._listeners = [];
    this._reconnectingIntervalId = null;
    this.send = (msg) => {
      this._ws.send(JSON.stringify([msg]));
    };
    this.resetConnection = () => {
      if (this._ws) {
        this._listeners.forEach((list) => {
          var _a;
          (_a = list == null ? void 0 : list.destroy) == null ? void 0 : _a.call(list);
        });
        this._ws.removeAllListeners();
        this._ws.terminate();
        this._ws.close();
        this._ws = null;
        this._listeners = [];
      }
    };
    this._sdkType = "SERVER" /* SERVER */;
    this.connect();
  }
  // protected addListener({
  //   lis,
  //   check,
  //   groupKey,
  // }: {
  //   lis: (v: any) => any;
  //   check: (v: any) => any;
  //   groupKey?: string;
  // }) {
  //   const listener = (msg: any) => {
  //     if (msg?.error) {
  //       lis(msg);
  //     } else if (check(msg)) {
  //       lis(msg);
  //     }
  //   };
  //   const groupListener = { key: getUUID(), listener, groupKey };
  //   this._listeners.push(groupListener);
  //   const destroy = () => {
  //     this._listeners = removeListener(this._listeners, groupListener);
  //   };
  //   return {
  //     destroy,
  //   };
  // }
  async connect() {
    if (!this._url)
      return;
    this.resetConnection();
    this._ws = new WebSocket2(this._url, {
      perMessageDeflate: false
    });
    this._ws.on("error", () => {
    });
    this._ws.on("close", () => {
      this.handleClose();
    });
    this._ws.on("open", () => {
      if (this._reconnectingIntervalId) {
        clearInterval(this._reconnectingIntervalId);
      }
      if (this._connectionSessionUUID && this.isWebsocketReadyState()) {
        this.send({
          taskType: "authentication" /* AUTHENTICATION */,
          apiKey: this._apiKey,
          connectionSessionUUID: this._connectionSessionUUID
        });
      } else {
        if (this.isWebsocketReadyState()) {
          this.send({
            apiKey: this._apiKey,
            taskType: "authentication" /* AUTHENTICATION */
          });
        }
      }
      this.addListener({
        taskUUID: "authentication" /* AUTHENTICATION */,
        lis: (m) => {
          var _a, _b;
          if (m == null ? void 0 : m.error) {
            this._invalidAPIkey = m;
            return;
          }
          this._connectionSessionUUID = (_b = (_a = m == null ? void 0 : m["authentication" /* AUTHENTICATION */]) == null ? void 0 : _a[0]) == null ? void 0 : _b.connectionSessionUUID;
          this._invalidAPIkey = void 0;
        }
      });
    });
    this._ws.on("message", (e, isBinary) => {
      const data = isBinary ? e : e == null ? void 0 : e.toString();
      if (!data)
        return;
      const m = JSON.parse(data);
      this._listeners.forEach((lis) => {
        const result = lis.listener(m);
        if (result) {
          return;
        }
      });
    });
  }
  handleClose() {
    if (this._invalidAPIkey) {
      return;
    }
    if (this._reconnectingIntervalId) {
      clearInterval(this._reconnectingIntervalId);
    }
    if (this._shouldReconnect) {
      setTimeout(() => this.connect(), 1e3);
    }
  }
  heartBeat() {
    clearTimeout(this._pingTimeout);
    this._pingTimeout = setTimeout(() => {
      if (this.isWebsocketReadyState()) {
        this.send({ ping: true });
      }
    }, 5e3);
  }
  //end of data
};

// Runware/Runware.ts
var Runware;
if (typeof window === "undefined") {
  Runware = RunwareServer;
} else {
  Runware = RunwareClient;
}
export {
  EControlMode,
  EOpenPosePreProcessor,
  EPreProcessor,
  EPreProcessorGroup,
  ETaskType,
  Environment,
  Runware,
  RunwareClient,
  RunwareServer,
  SdkType
};
