declare enum Environment {
    PRODUCTION = "PRODUCTION",
    DEVELOPMENT = "DEVELOPMENT",
    TEST = "TEST"
}
declare enum SdkType {
    CLIENT = "CLIENT",
    SERVER = "SERVER"
}
declare enum ETaskType {
    IMAGE_INFERENCE = "imageInference",
    IMAGE_UPLOAD = "imageUpload",
    IMAGE_UPSCALE = "imageUpscale",
    IMAGE_BACKGROUND_REMOVAL = "imageBackgroundRemoval",
    IMAGE_CAPTION = "imageCaption",
    IMAGE_CONTROL_NET_PRE_PROCESS = "imageControlNetPreProcess",
    PROMPT_ENHANCE = "promptEnhance",
    AUTHENTICATION = "authentication"
}
type RunwareBaseType = {
    apiKey: string;
    url?: string;
    shouldReconnect?: boolean;
    globalMaxRetries?: number;
    timeoutDuration?: number;
};
type IOutputType = "base64Data" | "dataURI" | "URL";
type IOutputFormat = "JPG" | "PNG" | "WEBP";
interface IImage {
    taskType: ETaskType;
    imageUUID: string;
    inputImageUUID?: string;
    taskUUID: string;
    imageURL?: string;
    imageBase64Data?: string;
    imageDataURI?: string;
    NSFWContent?: boolean;
    cost?: number;
}
interface ITextToImage extends IImage {
    positivePrompt?: string;
    negativePrompt?: string;
}
interface IControlNetImage {
    taskUUID: string;
    inputImageUUID: string;
    guideImageUUID: string;
    guideImageURL?: string;
    guideImageBase64Data?: string;
    guideImageDataURI?: string;
    cost?: number;
}
interface ILora {
    model: string | number;
    weight: number;
}
declare enum EControlMode {
    BALANCED = "balanced",
    PROMPT = "prompt",
    CONTROL_NET = "controlnet"
}
type IControlNetGeneral = {
    model: string;
    guideImage: string | File;
    weight?: number;
    startStep?: number;
    startStepPercentage?: number;
    endStep?: number;
    endStepPercentage?: number;
    controlMode: EControlMode;
};
type IControlNetPreprocess = {
    inputImage: string | File;
    preProcessor: EPreProcessorGroup;
    height?: number;
    width?: number;
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    highThresholdCanny?: number;
    lowThresholdCanny?: number;
    includeHandsAndFaceOpenPose?: boolean;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
};
type IControlNet = IControlNetGeneral;
type IControlNetWithUUID = Omit<IControlNet, "guideImage"> & {
    guideImage?: string;
};
interface IError {
    error: boolean;
    errorMessage: string;
    taskUUID: string;
}
interface IRequestImage {
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    uploadEndpoint?: string;
    checkNsfw?: boolean;
    positivePrompt: string;
    negativePrompt?: string;
    seedImage?: File | string;
    maskImage?: File | string;
    strength?: number;
    height?: number;
    width?: number;
    model: number | string;
    steps?: number;
    scheduler?: string;
    seed?: number;
    CFGScale?: number;
    clipSkip?: number;
    usePromptWeighting?: boolean;
    numberResults?: number;
    controlNet?: IControlNet[];
    lora?: ILora[];
    includeCost?: boolean;
    customTaskUUID?: string;
    onPartialImages?: (images: IImage[], error?: IError) => void;
    retry?: number;
}
interface IRequestImageToText {
    inputImage?: File | string;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
}
interface IImageToText {
    taskType: ETaskType;
    taskUUID: string;
    text: string;
    cost?: number;
}
interface IRemoveImageBackground extends IRequestImageToText {
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    rgba?: number[];
    postProcessMask?: boolean;
    returnOnlyMask?: boolean;
    alphaMatting?: boolean;
    alphaMattingForegroundThreshold?: number;
    alphaMattingBackgroundThreshold?: number;
    alphaMattingErodeSize?: number;
    includeCost?: boolean;
    retry?: number;
}
interface IRemoveImage {
    taskType: ETaskType;
    taskUUID: string;
    imageUUID: string;
    inputImageUUID: string;
    imageURL?: string;
    imageBase64Data?: string;
    imageDataURI?: string;
    cost?: number;
}
interface IPromptEnhancer {
    promptMaxLength?: number;
    promptVersions?: number;
    prompt: string;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
}
interface IEnhancedPrompt extends IImageToText {
}
interface IUpscaleGan {
    inputImage: File | string;
    upscaleFactor: number;
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
}
type ReconnectingWebsocketProps = {
    addEventListener: (type: string, listener: EventListener, options: any) => void;
    send: (data: any) => void;
} & WebSocket;
type UploadImageType = {
    imageURL: string;
    imageUUID: string;
    taskUUID: string;
    taskType: ETaskType;
};
type GetWithPromiseCallBackType = ({ resolve, reject, intervalId, }: {
    resolve: <T>(value: T) => void;
    reject: <T>(value: T) => void;
    intervalId: any;
}) => boolean | undefined;
declare enum EPreProcessorGroup {
    "canny" = "canny",
    "depth" = "depth",
    "mlsd" = "mlsd",
    "normalbae" = "normalbae",
    "openpose" = "openpose",
    "tile" = "tile",
    "seg" = "seg",
    "lineart" = "lineart",
    "lineart_anime" = "lineart_anime",
    "shuffle" = "shuffle",
    "scribble" = "scribble",
    "softedge" = "softedge"
}
declare enum EPreProcessor {
    "canny" = "canny",
    "depth_leres" = "depth_leres",
    "depth_midas" = "depth_midas",
    "depth_zoe" = "depth_zoe",
    "inpaint_global_harmonious" = "inpaint_global_harmonious",
    "lineart_anime" = "lineart_anime",
    "lineart_coarse" = "lineart_coarse",
    "lineart_realistic" = "lineart_realistic",
    "lineart_standard" = "lineart_standard",
    "mlsd" = "mlsd",
    "normal_bae" = "normal_bae",
    "scribble_hed" = "scribble_hed",
    "scribble_pidinet" = "scribble_pidinet",
    "seg_ofade20k" = "seg_ofade20k",
    "seg_ofcoco" = "seg_ofcoco",
    "seg_ufade20k" = "seg_ufade20k",
    "shuffle" = "shuffle",
    "softedge_hed" = "softedge_hed",
    "softedge_hedsafe" = "softedge_hedsafe",
    "softedge_pidinet" = "softedge_pidinet",
    "softedge_pidisafe" = "softedge_pidisafe",
    "tile_gaussian" = "tile_gaussian",
    "openpose" = "openpose",
    "openpose_face" = "openpose_face",
    "openpose_faceonly" = "openpose_faceonly",
    "openpose_full" = "openpose_full",
    "openpose_hand" = "openpose_hand"
}
declare enum EOpenPosePreProcessor {
    "openpose" = "openpose",
    "openpose_face" = "openpose_face",
    "openpose_faceonly" = "openpose_faceonly",
    "openpose_full" = "openpose_full",
    "openpose_hand" = "openpose_hand"
}
type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;
}[Keys];
type ListenerType = {
    key: string;
    listener: (msg: any) => void;
    groupKey?: string;
};

declare class RunwareBase {
    _ws: ReconnectingWebsocketProps | any;
    _listeners: ListenerType[];
    _apiKey: string;
    _url?: string;
    _globalMessages: Record<string, any>;
    _globalImages: IImage[];
    _globalError: IError | undefined;
    _connectionSessionUUID: string | undefined;
    _invalidAPIkey: string | undefined;
    _sdkType: SdkType;
    _shouldReconnect: boolean;
    _globalMaxRetries: number;
    _timeoutDuration: number;
    constructor({ apiKey, url, shouldReconnect, globalMaxRetries, timeoutDuration, }: RunwareBaseType);
    static initialize(props: RunwareBaseType): Promise<RunwareBase>;
    protected isWebsocketReadyState: () => boolean;
    protected addListener({ lis, groupKey, taskUUID, }: {
        lis: (v: any) => any;
        groupKey?: string;
        taskUUID: string;
    }): {
        destroy: () => void;
    };
    protected connect(): void;
    protected send: (msg: Object) => void;
    private destroy;
    private uploadImage;
    private listenToImages;
    private globalListener;
    requestImages({ outputType, outputFormat, uploadEndpoint, checkNsfw, positivePrompt, negativePrompt, seedImage, maskImage, strength, height, width, model, steps, scheduler, seed, CFGScale, clipSkip, usePromptWeighting, numberResults, controlNet, lora, onPartialImages, includeCost, customTaskUUID, retry, }: IRequestImage): Promise<ITextToImage[] | undefined>;
    controlNetPreProcess: ({ inputImage, preProcessor, height, width, outputType, outputFormat, highThresholdCanny, lowThresholdCanny, includeHandsAndFaceOpenPose, includeCost, customTaskUUID, retry, }: IControlNetPreprocess) => Promise<IControlNetImage | null>;
    requestImageToText: ({ inputImage, includeCost, customTaskUUID, retry, }: IRequestImageToText) => Promise<IImageToText>;
    removeImageBackground: ({ inputImage, outputType, outputFormat, rgba, postProcessMask, returnOnlyMask, alphaMatting, alphaMattingForegroundThreshold, alphaMattingBackgroundThreshold, alphaMattingErodeSize, includeCost, customTaskUUID, retry, }: IRemoveImageBackground) => Promise<IRemoveImage>;
    upscaleGan: ({ inputImage, upscaleFactor, outputType, outputFormat, includeCost, customTaskUUID, retry, }: IUpscaleGan) => Promise<IImage>;
    enhancePrompt: ({ prompt, promptMaxLength, promptVersions, includeCost, customTaskUUID, retry, }: IPromptEnhancer) => Promise<IEnhancedPrompt[]>;
    ensureConnection(): Promise<unknown>;
    private getSimilarImages;
    private getSingleMessage;
    private handleIncompleteImages;
    disconnect: () => Promise<void>;
    private connected;
}

declare class RunwareClient extends RunwareBase {
    constructor(props: RunwareBaseType);
}

declare class RunwareServer extends RunwareBase {
    _instantiated: boolean;
    _listeners: any[];
    _reconnectingIntervalId: null | any;
    _pingTimeout: any;
    _pongListener: any;
    constructor(props: RunwareBaseType);
    protected connect(): Promise<void>;
    protected send: (msg: Object) => void;
    protected handleClose(): void;
    protected resetConnection: () => void;
    protected heartBeat(): void;
}

declare let Runware: typeof RunwareClient | typeof RunwareServer;

export { EControlMode, EOpenPosePreProcessor, EPreProcessor, EPreProcessorGroup, ETaskType, Environment, GetWithPromiseCallBackType, IControlNet, IControlNetGeneral, IControlNetImage, IControlNetPreprocess, IControlNetWithUUID, IEnhancedPrompt, IError, IImage, IImageToText, IOutputFormat, IOutputType, IPromptEnhancer, IRemoveImage, IRemoveImageBackground, IRequestImage, IRequestImageToText, ITextToImage, IUpscaleGan, ListenerType, ReconnectingWebsocketProps, RequireAtLeastOne, RequireOnlyOne, Runware, RunwareBaseType, RunwareClient, RunwareServer, SdkType, UploadImageType };
