var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// Runware/types.ts
var Environment, SdkType, ETaskType, EControlMode, EPreProcessorGroup, EPreProcessor, EOpenPosePreProcessor;
var init_types = __esm({
  "Runware/types.ts"() {
    "use strict";
    Environment = /* @__PURE__ */ ((Environment2) => {
      Environment2["PRODUCTION"] = "PRODUCTION";
      Environment2["DEVELOPMENT"] = "DEVELOPMENT";
      Environment2["TEST"] = "TEST";
      return Environment2;
    })(Environment || {});
    SdkType = /* @__PURE__ */ ((SdkType2) => {
      SdkType2["CLIENT"] = "CLIENT";
      SdkType2["SERVER"] = "SERVER";
      return SdkType2;
    })(SdkType || {});
    ETaskType = /* @__PURE__ */ ((ETaskType2) => {
      ETaskType2["IMAGE_INFERENCE"] = "imageInference";
      ETaskType2["IMAGE_UPLOAD"] = "imageUpload";
      ETaskType2["IMAGE_UPSCALE"] = "imageUpscale";
      ETaskType2["IMAGE_BACKGROUND_REMOVAL"] = "imageBackgroundRemoval";
      ETaskType2["IMAGE_CAPTION"] = "imageCaption";
      ETaskType2["IMAGE_CONTROL_NET_PRE_PROCESS"] = "imageControlNetPreProcess";
      ETaskType2["PROMPT_ENHANCE"] = "promptEnhance";
      ETaskType2["AUTHENTICATION"] = "authentication";
      return ETaskType2;
    })(ETaskType || {});
    EControlMode = /* @__PURE__ */ ((EControlMode2) => {
      EControlMode2["BALANCED"] = "balanced";
      EControlMode2["PROMPT"] = "prompt";
      EControlMode2["CONTROL_NET"] = "controlnet";
      return EControlMode2;
    })(EControlMode || {});
    EPreProcessorGroup = /* @__PURE__ */ ((EPreProcessorGroup3) => {
      EPreProcessorGroup3["canny"] = "canny";
      EPreProcessorGroup3["depth"] = "depth";
      EPreProcessorGroup3["mlsd"] = "mlsd";
      EPreProcessorGroup3["normalbae"] = "normalbae";
      EPreProcessorGroup3["openpose"] = "openpose";
      EPreProcessorGroup3["tile"] = "tile";
      EPreProcessorGroup3["seg"] = "seg";
      EPreProcessorGroup3["lineart"] = "lineart";
      EPreProcessorGroup3["lineart_anime"] = "lineart_anime";
      EPreProcessorGroup3["shuffle"] = "shuffle";
      EPreProcessorGroup3["scribble"] = "scribble";
      EPreProcessorGroup3["softedge"] = "softedge";
      return EPreProcessorGroup3;
    })(EPreProcessorGroup || {});
    EPreProcessor = /* @__PURE__ */ ((EPreProcessor3) => {
      EPreProcessor3["canny"] = "canny";
      EPreProcessor3["depth_leres"] = "depth_leres";
      EPreProcessor3["depth_midas"] = "depth_midas";
      EPreProcessor3["depth_zoe"] = "depth_zoe";
      EPreProcessor3["inpaint_global_harmonious"] = "inpaint_global_harmonious";
      EPreProcessor3["lineart_anime"] = "lineart_anime";
      EPreProcessor3["lineart_coarse"] = "lineart_coarse";
      EPreProcessor3["lineart_realistic"] = "lineart_realistic";
      EPreProcessor3["lineart_standard"] = "lineart_standard";
      EPreProcessor3["mlsd"] = "mlsd";
      EPreProcessor3["normal_bae"] = "normal_bae";
      EPreProcessor3["scribble_hed"] = "scribble_hed";
      EPreProcessor3["scribble_pidinet"] = "scribble_pidinet";
      EPreProcessor3["seg_ofade20k"] = "seg_ofade20k";
      EPreProcessor3["seg_ofcoco"] = "seg_ofcoco";
      EPreProcessor3["seg_ufade20k"] = "seg_ufade20k";
      EPreProcessor3["shuffle"] = "shuffle";
      EPreProcessor3["softedge_hed"] = "softedge_hed";
      EPreProcessor3["softedge_hedsafe"] = "softedge_hedsafe";
      EPreProcessor3["softedge_pidinet"] = "softedge_pidinet";
      EPreProcessor3["softedge_pidisafe"] = "softedge_pidisafe";
      EPreProcessor3["tile_gaussian"] = "tile_gaussian";
      EPreProcessor3["openpose"] = "openpose";
      EPreProcessor3["openpose_face"] = "openpose_face";
      EPreProcessor3["openpose_faceonly"] = "openpose_faceonly";
      EPreProcessor3["openpose_full"] = "openpose_full";
      EPreProcessor3["openpose_hand"] = "openpose_hand";
      return EPreProcessor3;
    })(EPreProcessor || {});
    EOpenPosePreProcessor = /* @__PURE__ */ ((EOpenPosePreProcessor2) => {
      EOpenPosePreProcessor2["openpose"] = "openpose";
      EOpenPosePreProcessor2["openpose_face"] = "openpose_face";
      EOpenPosePreProcessor2["openpose_faceonly"] = "openpose_faceonly";
      EOpenPosePreProcessor2["openpose_full"] = "openpose_full";
      EOpenPosePreProcessor2["openpose_hand"] = "openpose_hand";
      return EOpenPosePreProcessor2;
    })(EOpenPosePreProcessor || {});
  }
});

// Runware/utils.ts
import { v4 as uuidv4, validate as validateUUID } from "uuid";
var TIMEOUT_DURATION, POLLING_INTERVAL, BASE_RUNWARE_URLS, removeFromAray, getIntervalWithPromise, fileToBase64, getUUID, isValidUUID, accessDeepObject, delay, removeListener, evaluateNonTrue;
var init_utils = __esm({
  "Runware/utils.ts"() {
    "use strict";
    init_types();
    TIMEOUT_DURATION = 6e4;
    POLLING_INTERVAL = 100;
    BASE_RUNWARE_URLS = {
      ["PRODUCTION" /* PRODUCTION */]: "wss://ws-api.runware.ai/v1",
      ["TEST" /* TEST */]: "ws://localhost:8080"
    };
    removeFromAray = (col, targetElem) => {
      if (col == null) {
        return;
      }
      let i = col.indexOf(targetElem);
      if (i === -1) {
        return;
      }
      col.splice(i, 1);
    };
    getIntervalWithPromise = (callback, {
      debugKey = "debugKey",
      timeOutDuration = TIMEOUT_DURATION,
      shouldThrowError = true
    }) => {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          if (intervalId) {
            clearInterval(intervalId);
            if (shouldThrowError) {
              reject(`Message could not be received for ${debugKey}`);
              console.error("Message could not be received for ", debugKey);
            }
          }
          clearTimeout(timeoutId);
        }, timeOutDuration);
        let intervalId = setInterval(async () => {
          const shouldClear = callback({ resolve, reject, intervalId });
          if (shouldClear) {
            clearInterval(intervalId);
            clearTimeout(timeoutId);
          }
        }, POLLING_INTERVAL);
      });
    };
    fileToBase64 = (file) => new Promise((resolve) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = function() {
        resolve(reader.result);
      };
    });
    getUUID = () => uuidv4();
    isValidUUID = (uuid) => validateUUID(uuid);
    accessDeepObject = ({
      key,
      data,
      useZero = true,
      shouldReturnString = false
    }) => {
      const splittedKeys = key.split(/\.|\[/).map((key2) => key2.replace(/\]$/, ""));
      const value = splittedKeys.reduce((acc, curr) => {
        var _a, _b;
        const returnZero = useZero ? 0 : void 0;
        const currentValue = acc == null ? void 0 : acc[curr];
        if (!currentValue) {
          return returnZero;
        }
        if (Array.isArray(currentValue) && /^\d+$/.test(curr)) {
          const index = parseInt(curr, 10);
          if (index >= 0 && index < currentValue.length) {
            return acc[curr] = currentValue[index];
          } else {
            return (_a = acc[curr]) != null ? _a : returnZero;
          }
        } else {
          return (_b = acc[curr]) != null ? _b : returnZero;
        }
      }, data || {});
      return value != null ? value : {};
    };
    delay = (time, milliseconds = 1e3) => {
      return new Promise((resolve) => setTimeout(resolve, time * milliseconds));
    };
    removeListener = (listeners, listener) => {
      return listeners.filter((lis) => lis.key !== listener.key);
    };
    evaluateNonTrue = ({
      key,
      value
    }) => {
      if (!!value || value === 0 || value === false) {
        return { [key]: value };
      } else {
        return {};
      }
    };
  }
});

// Runware/async-retry.ts
var asyncRetry;
var init_async_retry = __esm({
  "Runware/async-retry.ts"() {
    "use strict";
    init_utils();
    asyncRetry = async (apiCall, options = {}) => {
      var _a;
      const { delayInSeconds = 1, callback } = options;
      let maxRetries = (_a = options.maxRetries) != null ? _a : 1;
      while (maxRetries) {
        try {
          const result = await apiCall();
          return result;
        } catch (error) {
          callback == null ? void 0 : callback();
          maxRetries--;
          if (maxRetries > 0) {
            await delay(delayInSeconds);
            await asyncRetry(apiCall, __spreadProps(__spreadValues({}, options), { maxRetries }));
          } else {
            throw error;
          }
        }
      }
    };
  }
});

// Runware/Runware-base.ts
var RunwareBase;
var init_Runware_base = __esm({
  "Runware/Runware-base.ts"() {
    init_async_retry();
    init_types();
    init_utils();
    RunwareBase = class {
      constructor({ apiKey, url = BASE_RUNWARE_URLS.PRODUCTION }) {
        this._listeners = [];
        // _globalMessages: any[] = [];
        this._globalMessages = {};
        this._globalImages = [];
        this.isWebsocketReadyState = () => {
          var _a;
          return ((_a = this._ws) == null ? void 0 : _a.readyState) === 1;
        };
        // We moving to an array format, it make sense to consolidate all request to an array here
        this.send = (msg) => {
          this._ws.send(JSON.stringify([msg]));
        };
        this.uploadImage = async (file) => {
          try {
            return await asyncRetry(async () => {
              const taskUUID = getUUID();
              if (typeof file === "string" && isValidUUID(file)) {
                return {
                  imageURL: file,
                  imageUUID: file,
                  taskUUID,
                  taskType: "imageUpload" /* IMAGE_UPLOAD */
                };
              }
              const imageBase64 = typeof file === "string" ? file : await fileToBase64(file);
              this.send({
                taskType: "imageUpload" /* IMAGE_UPLOAD */,
                image: imageBase64,
                taskUUID
              });
              const lis = this.globalListener({
                taskUUID
              });
              const image = await getIntervalWithPromise(
                ({ resolve, reject }) => {
                  const uploadedImage = this.getSingleMessage({
                    taskUUID
                  });
                  if (!uploadedImage)
                    return;
                  if (uploadedImage == null ? void 0 : uploadedImage.error) {
                    reject(uploadedImage);
                    return true;
                  }
                  if (uploadedImage) {
                    delete this._globalMessages[taskUUID];
                    resolve(uploadedImage);
                    return true;
                  }
                },
                { debugKey: "upload-image" }
              );
              lis.destroy();
              return image;
            });
          } catch (e) {
            throw e;
          }
        };
        this.controlNetPreProcess = async ({
          inputImage,
          preProcessor,
          height,
          width,
          outputType,
          outputFormat,
          highThresholdCanny,
          lowThresholdCanny,
          includeHandsAndFaceOpenPose,
          includeCost,
          customTaskUUID
        }) => {
          try {
            const image = await this.uploadImage(inputImage);
            if (!(image == null ? void 0 : image.imageUUID))
              return null;
            const taskUUID = customTaskUUID || getUUID();
            this.send(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
              inputImage: image.imageUUID,
              taskType: "imageControlNetPreProcess" /* IMAGE_CONTROL_NET_PRE_PROCESS */,
              taskUUID,
              preProcessor
            }, evaluateNonTrue({ key: "height", value: height })), evaluateNonTrue({ key: "width", value: width })), evaluateNonTrue({ key: "outputType", value: outputType })), evaluateNonTrue({ key: "outputFormat", value: outputFormat })), evaluateNonTrue({ key: "includeCost", value: includeCost })), evaluateNonTrue({
              key: "highThresholdCanny",
              value: highThresholdCanny
            })), evaluateNonTrue({
              key: "lowThresholdCanny",
              value: lowThresholdCanny
            })), evaluateNonTrue({
              key: "includeHandsAndFaceOpenPose",
              value: includeHandsAndFaceOpenPose
            })));
            const lis = this.globalListener({
              taskUUID
            });
            const guideImage = await getIntervalWithPromise(
              ({ resolve, reject }) => {
                const uploadedImage = this.getSingleMessage({
                  taskUUID
                });
                if (!uploadedImage)
                  return;
                if (uploadedImage == null ? void 0 : uploadedImage.error) {
                  reject(uploadedImage);
                  return true;
                }
                if (uploadedImage) {
                  resolve(uploadedImage);
                  return true;
                }
              },
              { debugKey: "unprocessed-image" }
            );
            lis.destroy();
            return guideImage;
          } catch (e) {
            throw e;
          }
        };
        this.requestImageToText = async ({
          inputImage,
          includeCost,
          customTaskUUID
        }) => {
          try {
            await this.ensureConnection();
            return await asyncRetry(async () => {
              const imageUploaded = await this.uploadImage(
                inputImage
              );
              if (!(imageUploaded == null ? void 0 : imageUploaded.imageUUID))
                return null;
              const taskUUID = customTaskUUID || getUUID();
              this.send(__spreadValues({
                taskUUID,
                taskType: "imageCaption" /* IMAGE_CAPTION */,
                inputImage: imageUploaded.imageUUID
              }, evaluateNonTrue({ key: "includeCost", value: includeCost })));
              const lis = this.globalListener({
                taskUUID
              });
              const response = await getIntervalWithPromise(
                ({ resolve, reject }) => {
                  const newReverseClip = this.getSingleMessage({
                    taskUUID
                  });
                  if (!newReverseClip)
                    return;
                  if (newReverseClip == null ? void 0 : newReverseClip.error) {
                    reject(newReverseClip);
                    return true;
                  }
                  if (newReverseClip) {
                    delete this._globalMessages[taskUUID];
                    resolve(newReverseClip);
                    return true;
                  }
                },
                { debugKey: "remove-image-background" }
              );
              lis.destroy();
              return response;
            });
          } catch (e) {
            throw e;
          }
        };
        this.removeImageBackground = async ({
          inputImage,
          outputType,
          outputFormat,
          rgba,
          postProcessMask,
          returnOnlyMask,
          alphaMatting,
          alphaMattingForegroundThreshold,
          alphaMattingBackgroundThreshold,
          alphaMattingErodeSize,
          includeCost,
          customTaskUUID
        }) => {
          try {
            await this.ensureConnection();
            return await asyncRetry(async () => {
              const imageUploaded = inputImage ? await this.uploadImage(inputImage) : null;
              const taskUUID = customTaskUUID || getUUID();
              this.send(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
                taskType: "imageBackgroundRemoval" /* IMAGE_BACKGROUND_REMOVAL */,
                taskUUID,
                inputImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID
              }, evaluateNonTrue({ key: "rgba", value: rgba })), evaluateNonTrue({
                key: "postProcessMask",
                value: postProcessMask
              })), evaluateNonTrue({ key: "returnOnlyMask", value: returnOnlyMask })), evaluateNonTrue({ key: "alphaMatting", value: alphaMatting })), evaluateNonTrue({ key: "includeCost", value: includeCost })), evaluateNonTrue({
                key: "alphaMattingForegroundThreshold",
                value: alphaMattingForegroundThreshold
              })), evaluateNonTrue({
                key: "alphaMattingBackgroundThreshold",
                value: alphaMattingBackgroundThreshold
              })), evaluateNonTrue({
                key: "alphaMattingErodeSize",
                value: alphaMattingErodeSize
              })), evaluateNonTrue({ key: "outputType", value: outputType })), evaluateNonTrue({ key: "outputFormat", value: outputFormat })));
              const lis = this.globalListener({
                taskUUID
              });
              const response = await getIntervalWithPromise(
                ({ resolve, reject }) => {
                  const newRemoveBackground = this.getSingleMessage({ taskUUID });
                  if (!newRemoveBackground)
                    return;
                  if (newRemoveBackground == null ? void 0 : newRemoveBackground.error) {
                    reject(newRemoveBackground);
                    return true;
                  }
                  if (newRemoveBackground) {
                    delete this._globalMessages[taskUUID];
                    resolve([newRemoveBackground]);
                    return true;
                  }
                },
                { debugKey: "remove-image-background" }
              );
              lis.destroy();
              return response;
            });
          } catch (e) {
            throw e;
          }
        };
        this.upscaleGan = async ({
          inputImage,
          upscaleFactor,
          outputType,
          outputFormat,
          includeCost,
          customTaskUUID
        }) => {
          try {
            await this.ensureConnection();
            return await asyncRetry(async () => {
              let imageUploaded;
              imageUploaded = await this.uploadImage(inputImage);
              if (!(imageUploaded == null ? void 0 : imageUploaded.imageUUID))
                return null;
              const taskUUID = customTaskUUID || getUUID();
              this.send(__spreadValues(__spreadValues(__spreadValues({
                taskUUID,
                inputImage: imageUploaded == null ? void 0 : imageUploaded.imageUUID,
                taskType: "imageUpscale" /* IMAGE_UPSCALE */,
                upscaleFactor
              }, evaluateNonTrue({ key: "includeCost", value: includeCost })), outputType ? { outputType } : {}), outputFormat ? { outputFormat } : {}));
              const lis = this.globalListener({
                taskUUID
              });
              const response = await getIntervalWithPromise(
                ({ resolve, reject }) => {
                  const newUpscaleGan = this.getSingleMessage({ taskUUID });
                  if (!newUpscaleGan)
                    return;
                  if (newUpscaleGan == null ? void 0 : newUpscaleGan.error) {
                    reject(newUpscaleGan);
                    return true;
                  }
                  if (newUpscaleGan) {
                    delete this._globalMessages[taskUUID];
                    resolve([newUpscaleGan]);
                    return true;
                  }
                },
                { debugKey: "upscale-gan" }
              );
              lis.destroy();
              return response;
            });
          } catch (e) {
            throw e;
          }
        };
        this.enhancePrompt = async ({
          prompt,
          promptMaxLength = 380,
          promptVersions = 1,
          includeCost,
          customTaskUUID
        }) => {
          try {
            await this.ensureConnection();
            return await asyncRetry(async () => {
              const taskUUID = customTaskUUID || getUUID();
              this.send(__spreadProps(__spreadValues({
                prompt,
                taskUUID,
                promptMaxLength,
                promptVersions
              }, evaluateNonTrue({ key: "includeCost", value: includeCost })), {
                taskType: "promptEnhance" /* PROMPT_ENHANCE */
              }));
              const lis = this.globalListener({
                taskUUID
              });
              const response = await getIntervalWithPromise(
                ({ resolve, reject }) => {
                  const reducedPrompt = this._globalMessages[taskUUID];
                  if (reducedPrompt == null ? void 0 : reducedPrompt.error) {
                    reject(reducedPrompt);
                    return true;
                  }
                  if ((reducedPrompt == null ? void 0 : reducedPrompt.length) >= promptVersions) {
                    delete this._globalMessages[taskUUID];
                    resolve(reducedPrompt);
                    return true;
                  }
                },
                { debugKey: "enhance-prompt" }
              );
              lis.destroy();
              return response;
            });
          } catch (e) {
            throw e;
          }
        };
        this.getSingleMessage = ({ taskUUID }) => {
          var _a;
          const value = this._globalMessages[taskUUID] || ((_a = this._globalMessages[taskUUID]) == null ? void 0 : _a[0]);
          if (!value)
            return null;
          return value;
        };
        this.disconnect = () => {
          var _a, _b, _c, _d;
          (_b = (_a = this._ws) == null ? void 0 : _a.terminate) == null ? void 0 : _b.call(_a);
          (_d = (_c = this._ws) == null ? void 0 : _c.close) == null ? void 0 : _d.call(_c);
        };
        this.connected = () => this.isWebsocketReadyState() && !!this._connectionSessionUUID;
        this._apiKey = apiKey;
        this._url = url;
        this._sdkType = "CLIENT" /* CLIENT */;
      }
      // protected addListener({
      //   lis,
      //   check,
      // }: {
      //   lis: (v: any) => any;
      //   check: (v: any) => any;
      //   groupKey?: string;
      // }): { destroy: Function } {
      //   this._ws.onmessage = (e: any) => {
      //     const m = JSON.parse(e.data);
      //     if (m?.error) {
      //       lis(m);
      //     } else if (check(m)) {
      //       lis(m);
      //     }
      //   };
      //   return {
      //     destroy: () => {},
      //   };
      // }
      addListener({
        lis,
        // check,
        groupKey,
        taskUUID
      }) {
        const listener = (msg) => {
          var _a;
          const arrayMessage = Array.isArray(msg == null ? void 0 : msg.data) ? msg.data : [msg.data];
          const arrayErrors = Array.isArray(msg == null ? void 0 : msg.errors) ? msg.errors : [msg.errors];
          const filteredMessage = arrayMessage.filter(
            (v) => ((v == null ? void 0 : v.taskUUID) || (v == null ? void 0 : v.taskType)) === taskUUID
          );
          const filteredErrors = arrayErrors.filter(
            (v) => ((v == null ? void 0 : v.taskUUID) || (v == null ? void 0 : v.taskType)) === taskUUID
          );
          if (filteredErrors.length) {
            lis({ error: __spreadValues({}, (_a = arrayErrors[0]) != null ? _a : {}) });
            return;
          }
          if (filteredMessage.length) {
            lis({ [taskUUID]: arrayMessage });
            return;
          }
        };
        const groupListener = { key: getUUID(), listener, groupKey };
        this._listeners.push(groupListener);
        const destroy = () => {
          this._listeners = removeListener(this._listeners, groupListener);
        };
        return {
          destroy
        };
      }
      connect() {
        this._ws.onopen = (e) => {
          if (this._connectionSessionUUID) {
            this.send({
              taskType: "authentication" /* AUTHENTICATION */,
              apiKey: this._apiKey,
              connectionSessionUUID: this._connectionSessionUUID
            });
          } else {
            this.send({ apiKey: this._apiKey, taskType: "authentication" /* AUTHENTICATION */ });
          }
          this.addListener({
            taskUUID: "authentication" /* AUTHENTICATION */,
            lis: (m) => {
              var _a, _b;
              if (m == null ? void 0 : m.error) {
                this._invalidAPIkey = "Invalid API key";
                return;
              }
              this._connectionSessionUUID = (_b = (_a = m == null ? void 0 : m["authentication" /* AUTHENTICATION */]) == null ? void 0 : _a[0]) == null ? void 0 : _b.connectionSessionUUID;
              this._invalidAPIkey = void 0;
            }
          });
        };
        this._ws.onmessage = (e) => {
          var _a;
          const data = JSON.parse(e.data);
          for (const lis of this._listeners) {
            const result = (_a = lis == null ? void 0 : lis.listener) == null ? void 0 : _a.call(lis, data);
            if (result)
              return;
          }
        };
        this._ws.onclose = (e) => {
          if (this._invalidAPIkey) {
            console.error(this._invalidAPIkey);
            return;
          }
        };
      }
      destroy(lis) {
        removeFromAray(this._listeners, lis);
      }
      listenToImages({
        onPartialImages,
        taskUUID,
        groupKey,
        positivePrompt,
        negativePrompt
      }) {
        return this.addListener({
          taskUUID,
          lis: (m) => {
            var _a, _b;
            let images = (_a = m == null ? void 0 : m[taskUUID]) == null ? void 0 : _a.filter(
              (img) => img.taskUUID === taskUUID
            );
            if (m.error) {
              onPartialImages == null ? void 0 : onPartialImages(images, (m == null ? void 0 : m.error) && m);
              this._globalError = m;
            } else {
              images = images.map((image) => __spreadProps(__spreadValues({}, image), {
                positivePrompt,
                negativePrompt
              }));
              onPartialImages == null ? void 0 : onPartialImages(images, (m == null ? void 0 : m.error) && m);
              if (this._sdkType === "CLIENT" /* CLIENT */) {
                this._globalImages = [
                  ...this._globalImages,
                  ...((_b = m == null ? void 0 : m[taskUUID]) != null ? _b : []).map((image) => __spreadProps(__spreadValues({}, image), {
                    positivePrompt,
                    negativePrompt
                  }))
                ];
              } else {
                this._globalImages = [...this._globalImages, ...images];
              }
            }
          },
          groupKey
        });
      }
      globalListener({ taskUUID }) {
        return this.addListener({
          // check: (m) => {
          //   const value = accessDeepObject({
          //     key: responseKey,
          //     data: m,
          //     useZero: false,
          //   });
          //   return !!value;
          // },
          // check: responseKey,
          taskUUID,
          lis: (m) => {
            console.log("m", m);
            if (m.error) {
              this._globalMessages[taskUUID] = m;
              return;
            }
            const value = accessDeepObject({
              key: taskUUID,
              data: m,
              useZero: false
            });
            if (Array.isArray(value)) {
              value.forEach((v) => {
                var _a;
                this._globalMessages[v.taskUUID] = [
                  ...(_a = this._globalMessages[v.taskUUID]) != null ? _a : [],
                  v
                ];
              });
            } else {
              this._globalMessages[value.taskUUID] = value;
            }
          }
        });
      }
      async requestImages({
        outputType,
        outputFormat,
        uploadEndpoint,
        checkNsfw,
        positivePrompt,
        negativePrompt,
        seedImage,
        maskImage,
        strength,
        height,
        width,
        model,
        steps,
        scheduler,
        seed,
        CFGScale,
        clipSkip,
        usePromptWeighting,
        numberResults = 1,
        controlNet,
        lora,
        onPartialImages,
        includeCost,
        customTaskUUID,
        retry = 2
      }) {
        await this.ensureConnection();
        let lis = void 0;
        let requestObject = void 0;
        let taskUUIDs = [];
        let retryCount = 0;
        try {
          await this.ensureConnection();
          let seedImageUUID = null;
          let maskImageUUID = null;
          let controlNetData = [];
          if (seedImage) {
            const uploadedImage = await this.uploadImage(seedImage);
            if (!uploadedImage)
              return [];
            seedImageUUID = uploadedImage.imageUUID;
          }
          if (maskImage) {
            const uploadedMaskInitiator = await this.uploadImage(maskImage);
            if (!uploadedMaskInitiator)
              return [];
            maskImageUUID = uploadedMaskInitiator.imageUUID;
          }
          if (controlNet == null ? void 0 : controlNet.length) {
            for (let i = 0; i < controlNet.length; i++) {
              const controlData = controlNet[i];
              const {
                endStep,
                startStep,
                weight,
                guideImage,
                controlMode,
                startStepPercentage,
                endStepPercentage,
                model: controlNetModel
              } = controlData;
              if (!guideImage)
                return;
              const imageUploaded = await this.uploadImage(
                guideImage
              );
              if (!imageUploaded)
                return;
              controlNetData.push(__spreadProps(__spreadValues(__spreadValues({
                guideImage: imageUploaded.imageUUID,
                model: controlNetModel,
                endStep,
                startStep,
                weight
              }, evaluateNonTrue({
                key: "startStepPercentage",
                value: startStepPercentage
              })), evaluateNonTrue({
                key: "endStepPercentage",
                value: endStepPercentage
              })), {
                controlMode: controlMode || "controlnet" /* CONTROL_NET */
              }));
            }
          }
          requestObject = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({
            taskType: "imageInference" /* IMAGE_INFERENCE */,
            model,
            positivePrompt
          }, negativePrompt ? { negativePrompt } : {}), height ? { height } : {}), width ? { width } : {}), {
            numberResults
          }), (lora == null ? void 0 : lora.length) ? { lora } : {}), outputType ? { outputType } : {}), outputFormat ? { outputFormat } : {}), uploadEndpoint ? { uploadEndpoint } : {}), evaluateNonTrue({ key: "checkNsfw", value: checkNsfw })), evaluateNonTrue({ key: "strength", value: strength })), evaluateNonTrue({ key: "CFGScale", value: CFGScale })), evaluateNonTrue({ key: "clipSkip", value: clipSkip })), evaluateNonTrue({
            key: "usePromptWeighting",
            value: usePromptWeighting
          })), evaluateNonTrue({ key: "steps", value: steps })), controlNetData.length ? { controlNet: controlNetData } : {}), seed ? { seed } : {}), scheduler ? { scheduler } : {}), evaluateNonTrue({ key: "includeCost", value: includeCost })), seedImageUUID ? { seedImage: seedImageUUID } : {}), maskImageUUID ? { maskImage: maskImageUUID } : {});
          return await asyncRetry(
            async () => {
              retryCount++;
              lis == null ? void 0 : lis.destroy();
              const imagesWithSimilarTask = this._globalImages.filter(
                (img) => taskUUIDs.includes(img.taskUUID)
              );
              const taskUUID = customTaskUUID || getUUID();
              taskUUIDs.push(taskUUID);
              const imageRemaining = numberResults - imagesWithSimilarTask.length;
              const newRequestObject = __spreadProps(__spreadValues({}, requestObject), {
                taskUUID,
                numberResults: imageRemaining
              });
              this.send(newRequestObject);
              lis = this.listenToImages({
                onPartialImages,
                taskUUID,
                groupKey: "REQUEST_IMAGES" /* REQUEST_IMAGES */,
                positivePrompt,
                negativePrompt
              });
              const promise = await this.getSimilarImages({
                taskUUID: taskUUIDs,
                numberResults,
                lis
              });
              lis.destroy();
              return promise;
            },
            {
              maxRetries: retry,
              callback: () => {
                lis == null ? void 0 : lis.destroy();
              }
            }
          );
        } catch (e) {
          if (e.taskUUID) {
            throw e;
          }
          if (retryCount >= retry) {
            return this.handleIncompleteImages({ taskUUIDs, error: e });
          }
        }
      }
      async ensureConnection() {
        var _a;
        let isConnected = this.connected();
        if (isConnected || this._url === BASE_RUNWARE_URLS.TEST)
          return;
        const retryInterval = 2e3;
        const pollingInterval = 200;
        try {
          if (this._invalidAPIkey)
            throw this._invalidAPIkey;
          return new Promise((resolve, reject) => {
            let retry = 0;
            const MAX_RETRY = 10;
            let retryIntervalId;
            let pollingIntervalId;
            const clearAllIntervals = () => {
              clearInterval(retryIntervalId);
              clearInterval(pollingIntervalId);
            };
            if (this._sdkType === "SERVER" /* SERVER */) {
              retryIntervalId = setInterval(async () => {
                try {
                  const hasConnected = this.connected();
                  if (hasConnected) {
                    clearAllIntervals();
                    resolve(true);
                  } else if (retry >= MAX_RETRY) {
                    clearAllIntervals();
                    reject(new Error("Retry timed out"));
                  } else {
                    this.connect();
                    retry++;
                  }
                } catch (error) {
                  clearAllIntervals();
                  reject(error);
                }
              }, retryInterval);
            }
            pollingIntervalId = setInterval(async () => {
              const hasConnected = this.connected();
              if (hasConnected) {
                clearAllIntervals();
                resolve(true);
              }
              if (!!this._invalidAPIkey) {
                clearAllIntervals();
                reject(new Error("Invalid API key"));
                return;
              }
            }, pollingInterval);
          });
          if (!isConnected) {
            this.connect();
            await delay(2);
          }
        } catch (e) {
          throw (_a = this._invalidAPIkey) != null ? _a : "Could not connect to server. Ensure your API key is correct";
        }
      }
      async getSimilarImages({
        taskUUID,
        numberResults,
        shouldThrowError,
        lis
      }) {
        return await getIntervalWithPromise(
          ({ resolve, reject, intervalId }) => {
            const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];
            const imagesWithSimilarTask = this._globalImages.filter(
              (img) => taskUUIDs.includes(img.taskUUID)
            );
            if (this._globalError) {
              const newData = this._globalError;
              this._globalError = void 0;
              clearInterval(intervalId);
              reject == null ? void 0 : reject(newData);
              return true;
            } else if (imagesWithSimilarTask.length >= numberResults) {
              clearInterval(intervalId);
              this._globalImages = this._globalImages.filter(
                (img) => !taskUUIDs.includes(img.taskUUID)
              );
              resolve([...imagesWithSimilarTask].slice(0, numberResults));
              return true;
            }
          },
          { debugKey: "getting images", shouldThrowError }
        );
      }
      handleIncompleteImages({
        taskUUIDs,
        error
      }) {
        const imagesWithSimilarTask = this._globalImages.filter(
          (img) => taskUUIDs.includes(img.taskUUID)
        );
        if (imagesWithSimilarTask.length > 1) {
          this._globalImages = this._globalImages.filter(
            (img) => !taskUUIDs.includes(img.taskUUID)
          );
          return imagesWithSimilarTask;
        } else {
          throw error;
        }
      }
      //end of data
    };
  }
});

export {
  __esm,
  __commonJS,
  __export,
  __toESM,
  __toCommonJS,
  Environment,
  SdkType,
  ETaskType,
  EControlMode,
  EPreProcessorGroup,
  EPreProcessor,
  EOpenPosePreProcessor,
  init_types,
  RunwareBase,
  init_Runware_base
};
