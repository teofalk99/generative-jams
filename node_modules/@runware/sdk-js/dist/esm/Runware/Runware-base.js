"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunwareBase = void 0;
// @ts-ignore
const async_retry_1 = require("./async-retry");
const types_1 = require("./types");
const utils_1 = require("./utils");
// let allImages: IImage[] = [];
class RunwareBase {
    constructor({ apiKey, url = utils_1.BASE_RUNWARE_URLS.PRODUCTION }) {
        this._listeners = [];
        // _globalMessages: any[] = [];
        this._globalMessages = {};
        this._globalImages = [];
        this.isWebsocketReadyState = () => { var _a; return ((_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) === 1; };
        // We moving to an array format, it make sense to consolidate all request to an array here
        this.send = (msg) => {
            this._ws.send(JSON.stringify([msg]));
        };
        this.uploadImage = async (file) => {
            try {
                return await (0, async_retry_1.asyncRetry)(async () => {
                    const taskUUID = (0, utils_1.getUUID)();
                    if (typeof file === "string" && (0, utils_1.isValidUUID)(file)) {
                        return {
                            imageURL: file,
                            imageUUID: file,
                            taskUUID,
                            taskType: types_1.ETaskType.IMAGE_UPLOAD,
                        };
                    }
                    const imageBase64 = typeof file === "string" ? file : await (0, utils_1.fileToBase64)(file);
                    this.send({
                        taskType: types_1.ETaskType.IMAGE_UPLOAD,
                        image: imageBase64,
                        taskUUID,
                    });
                    const lis = this.globalListener({
                        taskUUID,
                    });
                    const image = (await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                        const uploadedImage = this.getSingleMessage({
                            taskUUID,
                        });
                        if (!uploadedImage)
                            return;
                        if (uploadedImage === null || uploadedImage === void 0 ? void 0 : uploadedImage.error) {
                            reject(uploadedImage);
                            return true;
                        }
                        if (uploadedImage) {
                            delete this._globalMessages[taskUUID];
                            resolve(uploadedImage);
                            return true;
                        }
                    }, { debugKey: "upload-image" }));
                    lis.destroy();
                    return image;
                });
            }
            catch (e) {
                throw e;
            }
        };
        this.controlNetPreProcess = async ({ inputImage, preProcessor, height, width, outputType, outputFormat, highThresholdCanny, lowThresholdCanny, includeHandsAndFaceOpenPose, includeCost, customTaskUUID, }) => {
            try {
                const image = await this.uploadImage(inputImage);
                if (!(image === null || image === void 0 ? void 0 : image.imageUUID))
                    return null;
                const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                this.send(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ inputImage: image.imageUUID, taskType: types_1.ETaskType.IMAGE_CONTROL_NET_PRE_PROCESS, taskUUID,
                    preProcessor }, (0, utils_1.evaluateNonTrue)({ key: "height", value: height })), (0, utils_1.evaluateNonTrue)({ key: "width", value: width })), (0, utils_1.evaluateNonTrue)({ key: "outputType", value: outputType })), (0, utils_1.evaluateNonTrue)({ key: "outputFormat", value: outputFormat })), (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })), (0, utils_1.evaluateNonTrue)({
                    key: "highThresholdCanny",
                    value: highThresholdCanny,
                })), (0, utils_1.evaluateNonTrue)({
                    key: "lowThresholdCanny",
                    value: lowThresholdCanny,
                })), (0, utils_1.evaluateNonTrue)({
                    key: "includeHandsAndFaceOpenPose",
                    value: includeHandsAndFaceOpenPose,
                })));
                const lis = this.globalListener({
                    taskUUID,
                });
                const guideImage = (await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                    const uploadedImage = this.getSingleMessage({
                        taskUUID,
                    });
                    if (!uploadedImage)
                        return;
                    if (uploadedImage === null || uploadedImage === void 0 ? void 0 : uploadedImage.error) {
                        reject(uploadedImage);
                        return true;
                    }
                    if (uploadedImage) {
                        // delete this._globalMessages[taskUUID];
                        resolve(uploadedImage);
                        return true;
                    }
                }, { debugKey: "unprocessed-image" }));
                lis.destroy();
                return guideImage;
            }
            catch (e) {
                throw e;
            }
        };
        this.requestImageToText = async ({ inputImage, includeCost, customTaskUUID, }) => {
            try {
                await this.ensureConnection();
                return await (0, async_retry_1.asyncRetry)(async () => {
                    const imageUploaded = inputImage
                        ? await this.uploadImage(inputImage)
                        : null;
                    const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                    this.send(Object.assign({ taskUUID, taskType: types_1.ETaskType.IMAGE_CAPTION, inputImage: imageUploaded === null || imageUploaded === void 0 ? void 0 : imageUploaded.imageUUID }, (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })));
                    const lis = this.globalListener({
                        taskUUID,
                    });
                    const response = await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                        const newReverseClip = this.getSingleMessage({
                            taskUUID,
                        });
                        if (!newReverseClip)
                            return;
                        if (newReverseClip === null || newReverseClip === void 0 ? void 0 : newReverseClip.error) {
                            reject(newReverseClip);
                            return true;
                        }
                        if (newReverseClip) {
                            delete this._globalMessages[taskUUID];
                            resolve(newReverseClip);
                            return true;
                        }
                    }, { debugKey: "remove-image-background" });
                    lis.destroy();
                    return response;
                });
            }
            catch (e) {
                throw e;
            }
        };
        this.removeImageBackground = async ({ inputImage, outputType, outputFormat, rgba, postProcessMask, returnOnlyMask, alphaMatting, alphaMattingForegroundThreshold, alphaMattingBackgroundThreshold, alphaMattingErodeSize, includeCost, customTaskUUID, }) => {
            try {
                await this.ensureConnection();
                return await (0, async_retry_1.asyncRetry)(async () => {
                    const imageUploaded = inputImage
                        ? await this.uploadImage(inputImage)
                        : null;
                    const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                    this.send(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ taskType: types_1.ETaskType.IMAGE_BACKGROUND_REMOVAL, taskUUID, inputImage: imageUploaded === null || imageUploaded === void 0 ? void 0 : imageUploaded.imageUUID }, (0, utils_1.evaluateNonTrue)({ key: "rgba", value: rgba })), (0, utils_1.evaluateNonTrue)({
                        key: "postProcessMask",
                        value: postProcessMask,
                    })), (0, utils_1.evaluateNonTrue)({ key: "returnOnlyMask", value: returnOnlyMask })), (0, utils_1.evaluateNonTrue)({ key: "alphaMatting", value: alphaMatting })), (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })), (0, utils_1.evaluateNonTrue)({
                        key: "alphaMattingForegroundThreshold",
                        value: alphaMattingForegroundThreshold,
                    })), (0, utils_1.evaluateNonTrue)({
                        key: "alphaMattingBackgroundThreshold",
                        value: alphaMattingBackgroundThreshold,
                    })), (0, utils_1.evaluateNonTrue)({
                        key: "alphaMattingErodeSize",
                        value: alphaMattingErodeSize,
                    })), (0, utils_1.evaluateNonTrue)({ key: "outputType", value: outputType })), (0, utils_1.evaluateNonTrue)({ key: "outputFormat", value: outputFormat })));
                    const lis = this.globalListener({
                        taskUUID,
                    });
                    const response = await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                        const newRemoveBackground = this.getSingleMessage({ taskUUID });
                        if (!newRemoveBackground)
                            return;
                        if (newRemoveBackground === null || newRemoveBackground === void 0 ? void 0 : newRemoveBackground.error) {
                            reject(newRemoveBackground);
                            return true;
                        }
                        if (newRemoveBackground) {
                            delete this._globalMessages[taskUUID];
                            resolve(newRemoveBackground);
                            return true;
                        }
                    }, { debugKey: "remove-image-background" });
                    lis.destroy();
                    return response;
                });
            }
            catch (e) {
                throw e;
            }
        };
        this.upscaleGan = async ({ inputImage, upscaleFactor, outputType, outputFormat, includeCost, customTaskUUID, }) => {
            try {
                await this.ensureConnection();
                return await (0, async_retry_1.asyncRetry)(async () => {
                    let imageUploaded;
                    imageUploaded = await this.uploadImage(inputImage);
                    const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                    this.send(Object.assign(Object.assign(Object.assign({ taskUUID, inputImage: imageUploaded === null || imageUploaded === void 0 ? void 0 : imageUploaded.imageUUID, taskType: types_1.ETaskType.IMAGE_UPSCALE, upscaleFactor }, (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })), (outputType ? { outputType } : {})), (outputFormat ? { outputFormat } : {})));
                    const lis = this.globalListener({
                        taskUUID,
                    });
                    const response = await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                        const newUpscaleGan = this.getSingleMessage({ taskUUID });
                        if (!newUpscaleGan)
                            return;
                        if (newUpscaleGan === null || newUpscaleGan === void 0 ? void 0 : newUpscaleGan.error) {
                            reject(newUpscaleGan);
                            return true;
                        }
                        if (newUpscaleGan) {
                            delete this._globalMessages[taskUUID];
                            resolve(newUpscaleGan);
                            return true;
                        }
                    }, { debugKey: "upscale-gan" });
                    lis.destroy();
                    return response;
                });
            }
            catch (e) {
                throw e;
            }
        };
        this.enhancePrompt = async ({ prompt, promptMaxLength = 380, promptVersions = 1, includeCost, customTaskUUID, }) => {
            try {
                await this.ensureConnection();
                return await (0, async_retry_1.asyncRetry)(async () => {
                    const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                    this.send(Object.assign(Object.assign({ prompt,
                        taskUUID,
                        promptMaxLength,
                        promptVersions }, (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })), { taskType: types_1.ETaskType.PROMPT_ENHANCE }));
                    const lis = this.globalListener({
                        taskUUID,
                    });
                    const response = await (0, utils_1.getIntervalWithPromise)(({ resolve, reject }) => {
                        const reducedPrompt = this._globalMessages[taskUUID];
                        if (reducedPrompt === null || reducedPrompt === void 0 ? void 0 : reducedPrompt.error) {
                            reject(reducedPrompt);
                            return true;
                        }
                        if ((reducedPrompt === null || reducedPrompt === void 0 ? void 0 : reducedPrompt.length) >= promptVersions) {
                            delete this._globalMessages[taskUUID];
                            resolve(reducedPrompt);
                            return true;
                        }
                    }, { debugKey: "enhance-prompt" });
                    lis.destroy();
                    return response;
                });
            }
            catch (e) {
                throw e;
            }
        };
        this.getSingleMessage = ({ taskUUID }) => {
            var _a;
            const value = this._globalMessages[taskUUID] || ((_a = this._globalMessages[taskUUID]) === null || _a === void 0 ? void 0 : _a[0]);
            if (!value)
                return null;
            return value;
        };
        this.disconnect = async () => {
            var _a, _b, _c, _d;
            (_b = (_a = this._ws) === null || _a === void 0 ? void 0 : _a.terminate) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this._ws) === null || _c === void 0 ? void 0 : _c.close) === null || _d === void 0 ? void 0 : _d.call(_c);
        };
        this.connected = () => this.isWebsocketReadyState() && !!this._connectionSessionUUID;
        this._apiKey = apiKey;
        this._url = url;
        this._sdkType = types_1.SdkType.CLIENT;
    }
    // protected addListener({
    //   lis,
    //   check,
    // }: {
    //   lis: (v: any) => any;
    //   check: (v: any) => any;
    //   groupKey?: string;
    // }): { destroy: Function } {
    //   this._ws.onmessage = (e: any) => {
    //     const m = JSON.parse(e.data);
    //     if (m?.error) {
    //       lis(m);
    //     } else if (check(m)) {
    //       lis(m);
    //     }
    //   };
    //   return {
    //     destroy: () => {},
    //   };
    // }
    addListener({ lis, 
    // check,
    groupKey, taskUUID, }) {
        const listener = (msg) => {
            var _a;
            const arrayMessage = Array.isArray(msg === null || msg === void 0 ? void 0 : msg.data) ? msg.data : [msg.data];
            const arrayErrors = Array.isArray(msg === null || msg === void 0 ? void 0 : msg.errors)
                ? msg.errors
                : [msg.errors];
            // const filteredMessage = arrayMessage.filter(
            //   (v) => v?.taskType === check
            // );
            const filteredMessage = arrayMessage.filter((v) => ((v === null || v === void 0 ? void 0 : v.taskUUID) || (v === null || v === void 0 ? void 0 : v.taskType)) === taskUUID);
            const filteredErrors = arrayErrors.filter((v) => ((v === null || v === void 0 ? void 0 : v.taskUUID) || (v === null || v === void 0 ? void 0 : v.taskType)) === taskUUID);
            if (filteredErrors.length) {
                lis({ error: Object.assign({}, ((_a = arrayErrors[0]) !== null && _a !== void 0 ? _a : {})) });
                return;
            }
            if (filteredMessage.length) {
                lis({ [taskUUID]: arrayMessage });
                return;
            }
        };
        const groupListener = { key: (0, utils_1.getUUID)(), listener, groupKey };
        this._listeners.push(groupListener);
        const destroy = () => {
            this._listeners = (0, utils_1.removeListener)(this._listeners, groupListener);
        };
        return {
            destroy,
        };
    }
    connect() {
        this._ws.onopen = (e) => {
            if (this._connectionSessionUUID) {
                this.send({
                    taskType: types_1.ETaskType.AUTHENTICATION,
                    apiKey: this._apiKey,
                    connectionSessionUUID: this._connectionSessionUUID,
                });
            }
            else {
                this.send({ apiKey: this._apiKey, taskType: types_1.ETaskType.AUTHENTICATION });
            }
            this.addListener({
                taskUUID: types_1.ETaskType.AUTHENTICATION,
                lis: (m) => {
                    var _a, _b;
                    if (m === null || m === void 0 ? void 0 : m.error) {
                        this._invalidAPIkey = "Invalid API key";
                        return;
                    }
                    this._connectionSessionUUID =
                        (_b = (_a = m === null || m === void 0 ? void 0 : m[types_1.ETaskType.AUTHENTICATION]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.connectionSessionUUID;
                    this._invalidAPIkey = undefined;
                },
            });
        };
        this._ws.onmessage = (e) => {
            var _a;
            const data = JSON.parse(e.data);
            for (const lis of this._listeners) {
                const result = (_a = lis === null || lis === void 0 ? void 0 : lis.listener) === null || _a === void 0 ? void 0 : _a.call(lis, data);
                if (result)
                    return;
            }
        };
        this._ws.onclose = (e) => {
            // console.log("closing");
            // console.log("invalid", this._invalidAPIkey);
            if (this._invalidAPIkey) {
                console.error(this._invalidAPIkey);
                return;
            }
        };
    }
    destroy(lis) {
        (0, utils_1.removeFromAray)(this._listeners, lis);
    }
    listenToImages({ onPartialImages, taskUUID, groupKey, positivePrompt, negativePrompt, }) {
        return this.addListener({
            taskUUID: taskUUID,
            lis: (m) => {
                var _a, _b;
                let images = (_a = m === null || m === void 0 ? void 0 : m[taskUUID]) === null || _a === void 0 ? void 0 : _a.filter((img) => img.taskUUID === taskUUID);
                if (m.error) {
                    onPartialImages === null || onPartialImages === void 0 ? void 0 : onPartialImages(images, (m === null || m === void 0 ? void 0 : m.error) && m);
                    this._globalError = m;
                }
                else {
                    images = images.map((image) => (Object.assign(Object.assign({}, image), { positivePrompt,
                        negativePrompt })));
                    onPartialImages === null || onPartialImages === void 0 ? void 0 : onPartialImages(images, (m === null || m === void 0 ? void 0 : m.error) && m);
                    if (this._sdkType === types_1.SdkType.CLIENT) {
                        // this._globalImages = [...this._globalImages, ...m.images];
                        this._globalImages = [
                            ...this._globalImages,
                            ...((_b = m === null || m === void 0 ? void 0 : m[taskUUID]) !== null && _b !== void 0 ? _b : []).map((image) => (Object.assign(Object.assign({}, image), { positivePrompt,
                                negativePrompt }))),
                        ];
                    }
                    else {
                        this._globalImages = [...this._globalImages, ...images];
                    }
                }
            },
            groupKey,
        });
    }
    globalListener({ taskUUID }) {
        return this.addListener({
            // check: (m) => {
            //   const value = accessDeepObject({
            //     key: responseKey,
            //     data: m,
            //     useZero: false,
            //   });
            //   return !!value;
            // },
            // check: responseKey,
            taskUUID: taskUUID,
            lis: (m) => {
                if (m.error) {
                    this._globalMessages[taskUUID] = m;
                    return;
                }
                const value = (0, utils_1.accessDeepObject)({
                    key: taskUUID,
                    data: m,
                    useZero: false,
                });
                if (Array.isArray(value)) {
                    value.forEach((v) => {
                        var _a;
                        this._globalMessages[v.taskUUID] = [
                            ...((_a = this._globalMessages[v.taskUUID]) !== null && _a !== void 0 ? _a : []),
                            v,
                        ];
                    });
                }
                else {
                    this._globalMessages[value.taskUUID] = value;
                }
            },
        });
    }
    async requestImages({ outputType, outputFormat, uploadEndpoint, checkNsfw, positivePrompt, negativePrompt, seedImage, maskImage, strength, height, width, model, steps, scheduler, seed, CFGScale, clipSkip, usePromptWeighting, numberResults = 1, controlNet, lora, onPartialImages, includeCost, customTaskUUID, retry = 2, }) {
        await this.ensureConnection();
        let lis = undefined;
        let requestObject = undefined;
        let taskUUIDs = [];
        let retryCount = 0;
        try {
            await this.ensureConnection();
            let seedImageUUID = null;
            let maskImageUUID = null;
            let controlNetData = [];
            if (seedImage) {
                const uploadedImage = await this.uploadImage(seedImage);
                if (!uploadedImage)
                    return [];
                seedImageUUID = uploadedImage.imageUUID;
            }
            if (maskImage) {
                const uploadedMaskInitiator = await this.uploadImage(maskImage);
                if (!uploadedMaskInitiator)
                    return [];
                maskImageUUID = uploadedMaskInitiator.imageUUID;
            }
            if (controlNet === null || controlNet === void 0 ? void 0 : controlNet.length) {
                for (let i = 0; i < controlNet.length; i++) {
                    const controlData = controlNet[i];
                    const { endStep, startStep, weight, guideImage, controlMode, startStepPercentage, endStepPercentage, model: controlNetModel, } = controlData;
                    const imageUploaded = guideImage
                        ? await this.uploadImage(guideImage)
                        : null;
                    controlNetData.push(Object.assign(Object.assign(Object.assign({ guideImage: imageUploaded === null || imageUploaded === void 0 ? void 0 : imageUploaded.imageUUID, model: controlNetModel, endStep,
                        startStep,
                        weight }, (0, utils_1.evaluateNonTrue)({
                        key: "startStepPercentage",
                        value: startStepPercentage,
                    })), (0, utils_1.evaluateNonTrue)({
                        key: "endStepPercentage",
                        value: endStepPercentage,
                    })), { controlMode: controlMode || types_1.EControlMode.CONTROL_NET }));
                }
            }
            requestObject = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ taskType: types_1.ETaskType.IMAGE_INFERENCE, model, positivePrompt: positivePrompt }, (negativePrompt ? { negativePrompt } : {})), (height ? { height } : {})), (width ? { width } : {})), { numberResults }), ((lora === null || lora === void 0 ? void 0 : lora.length) ? { lora: lora } : {})), (outputType ? { outputType } : {})), (outputFormat ? { outputFormat } : {})), (uploadEndpoint ? { uploadEndpoint } : {})), (0, utils_1.evaluateNonTrue)({ key: "checkNsfw", value: checkNsfw })), (0, utils_1.evaluateNonTrue)({ key: "strength", value: strength })), (0, utils_1.evaluateNonTrue)({ key: "CFGScale", value: CFGScale })), (0, utils_1.evaluateNonTrue)({ key: "clipSkip", value: clipSkip })), (0, utils_1.evaluateNonTrue)({
                key: "usePromptWeighting",
                value: usePromptWeighting,
            })), (0, utils_1.evaluateNonTrue)({ key: "steps", value: steps })), (controlNetData.length ? { controlNet: controlNetData } : {})), (seed ? { seed: seed } : {})), (scheduler ? { scheduler } : {})), (0, utils_1.evaluateNonTrue)({ key: "includeCost", value: includeCost })), (seedImageUUID ? { seedImage: seedImageUUID } : {})), (maskImageUUID ? { maskImage: maskImageUUID } : {}));
            return await (0, async_retry_1.asyncRetry)(async () => {
                retryCount++;
                lis === null || lis === void 0 ? void 0 : lis.destroy();
                const imagesWithSimilarTask = this._globalImages.filter((img) => taskUUIDs.includes(img.taskUUID));
                const taskUUID = customTaskUUID || (0, utils_1.getUUID)();
                taskUUIDs.push(taskUUID);
                const imageRemaining = numberResults - imagesWithSimilarTask.length;
                const newRequestObject = Object.assign(Object.assign({}, requestObject), { taskUUID: taskUUID, numberResults: imageRemaining });
                this.send(newRequestObject);
                lis = this.listenToImages({
                    onPartialImages,
                    taskUUID: taskUUID,
                    groupKey: utils_1.LISTEN_TO_IMAGES_KEY.REQUEST_IMAGES,
                    positivePrompt,
                    negativePrompt,
                });
                const promise = await this.getSimilarImages({
                    taskUUID: taskUUIDs,
                    numberResults,
                    lis,
                });
                lis.destroy();
                return promise;
            }, {
                maxRetries: retry,
                callback: () => {
                    lis === null || lis === void 0 ? void 0 : lis.destroy();
                },
            });
        }
        catch (e) {
            if (e.taskUUID) {
                throw e;
            }
            if (retryCount >= retry) {
                return this.handleIncompleteImages({ taskUUIDs, error: e });
            }
        }
    }
    async ensureConnection() {
        var _a;
        let isConnected = this.connected();
        if (isConnected || this._url === utils_1.BASE_RUNWARE_URLS.TEST)
            return;
        const retryInterval = 2000;
        const pollingInterval = 200;
        // const pollingInterval = this._sdkType === SdkType.CLIENT ? 200 : 2000;
        try {
            if (this._invalidAPIkey)
                throw this._invalidAPIkey;
            return new Promise((resolve, reject) => {
                //  const isConnected =
                let retry = 0;
                const MAX_RETRY = 30;
                let retryIntervalId;
                let pollingIntervalId;
                const clearAllIntervals = () => {
                    clearInterval(retryIntervalId);
                    clearInterval(pollingIntervalId);
                };
                if (this._sdkType === types_1.SdkType.SERVER) {
                    retryIntervalId = setInterval(async () => {
                        try {
                            const hasConnected = this.connected();
                            if (hasConnected) {
                                clearAllIntervals();
                                resolve(true);
                            }
                            else if (retry >= MAX_RETRY) {
                                clearAllIntervals();
                                reject(new Error("Retry timed out"));
                            }
                            else {
                                this.connect();
                                retry++;
                            }
                        }
                        catch (error) {
                            clearAllIntervals();
                            reject(error);
                        }
                    }, retryInterval);
                }
                pollingIntervalId = setInterval(async () => {
                    const hasConnected = this.connected();
                    if (hasConnected) {
                        clearAllIntervals();
                        resolve(true);
                    }
                    if (!!this._invalidAPIkey) {
                        clearAllIntervals();
                        reject(new Error("Invalid API key"));
                        return;
                    }
                }, pollingInterval);
            });
            if (!isConnected) {
                this.connect();
                await (0, utils_1.delay)(2);
                // const listenerTaskUID = getUUID();
                // if (this._ws.readyState === 1) {
                //   this.send({
                //     newConnection: { apiKey: this._apiKey, taskUUID: listenerTaskUID },
                //   });
                // }
                // const lis = this.globalListener({
                //   responseKey: "newConnectionSessionUUID",
                //   taskType: "newConnectionSessionUUID.connectionSessionUUID",
                //   taskUUID: listenerTaskUID,
                // });
                // await getIntervalWithPromise(
                //   ({ resolve, reject }) => {
                //     const connectionId: string = this._globalMessages[listenerTaskUID];
                //     if ((connectionId as any)?.error) {
                //       reject(connectionId);
                //       return true;
                //     }
                //     if (connectionId) {
                //       delete this._globalMessages[listenerTaskUID];
                //       this._connectionSessionUUID = connectionId;
                //       resolve(connectionId);
                //       return true;
                //     }
                //   },
                //   { debugKey: "listen-to-connection" }
                // );
                // lis.destroy();
            }
        }
        catch (e) {
            throw ((_a = this._invalidAPIkey) !== null && _a !== void 0 ? _a : "Could not connect to server. Ensure your API key is correct");
        }
    }
    async getSimilarImages({ taskUUID, numberResults, shouldThrowError, lis, }) {
        return (await (0, utils_1.getIntervalWithPromise)(({ resolve, reject, intervalId }) => {
            var _a;
            const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];
            const imagesWithSimilarTask = this._globalImages.filter((img) => taskUUIDs.includes(img.taskUUID));
            if (this._globalError) {
                const newData = this._globalError;
                this._globalError = undefined;
                // throw errorData[0]
                clearInterval(intervalId);
                (_a = (reject)) === null || _a === void 0 ? void 0 : _a(newData);
                return true;
            }
            // onPartialImages?.(imagesWithSimilarTask)
            else if (imagesWithSimilarTask.length >= numberResults) {
                // lis?.destroy();
                clearInterval(intervalId);
                this._globalImages = this._globalImages.filter((img) => !taskUUIDs.includes(img.taskUUID));
                resolve([...imagesWithSimilarTask].slice(0, numberResults));
                return true;
                // Resolve the promise with the data
            }
        }, { debugKey: "getting images", shouldThrowError }));
    }
    handleIncompleteImages({ taskUUIDs, error, }) {
        const imagesWithSimilarTask = this._globalImages.filter((img) => taskUUIDs.includes(img.taskUUID));
        if (imagesWithSimilarTask.length > 1) {
            this._globalImages = this._globalImages.filter((img) => !taskUUIDs.includes(img.taskUUID));
            return imagesWithSimilarTask;
        }
        else {
            throw error;
        }
    }
}
exports.RunwareBase = RunwareBase;
