"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateNonTrue = exports.LISTEN_TO_IMAGES_KEY = exports.removeAllKeyListener = exports.removeListener = exports.remove1Mutate = exports.RETRY_SDK_COUNTS = exports.MockFile = exports.delay = exports.accessDeepObject = exports.getPreprocessorType = exports.compact = exports.isValidUUID = exports.getUUID = exports.fileToBase64 = exports.getIntervalWithPromise = exports.removeFromAray = exports.BASE_RUNWARE_URLS = void 0;
const types_1 = require("./types");
const uuid_1 = require("uuid");
const TIMEOUT_DURATION = 60000; // 120S;
const POLLING_INTERVAL = 100; // 1s;
exports.BASE_RUNWARE_URLS = {
    [types_1.Environment.PRODUCTION]: "wss://ws-api.runware.ai/v1",
    [types_1.Environment.TEST]: "ws://localhost:8080",
};
const removeFromAray = (col, targetElem) => {
    if (col == null) {
        return;
    }
    let i = col.indexOf(targetElem);
    if (i === -1) {
        return;
    }
    col.splice(i, 1);
};
exports.removeFromAray = removeFromAray;
const getIntervalWithPromise = (callback, { debugKey = "debugKey", timeOutDuration = TIMEOUT_DURATION, shouldThrowError = true, }) => {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
            if (intervalId) {
                clearInterval(intervalId);
                if (shouldThrowError) {
                    reject(`Message could not be received for ${debugKey}`);
                    console.error("Message could not be received for ", debugKey);
                }
            }
            clearTimeout(timeoutId);
            // reject();
        }, timeOutDuration);
        let intervalId = setInterval(async () => {
            const shouldClear = callback({ resolve, reject, intervalId });
            if (shouldClear) {
                clearInterval(intervalId);
                clearTimeout(timeoutId);
            }
            // resolve(imagesWithSimilarTask); // Resolve the promise with the data
        }, POLLING_INTERVAL); // Check every 1 second (adjust the interval as needed)
    });
};
exports.getIntervalWithPromise = getIntervalWithPromise;
const fileToBase64 = (file) => new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = function () {
        resolve(reader.result);
    };
});
exports.fileToBase64 = fileToBase64;
// export const getUUID = () => crypto.randomUUID();
const getUUID = () => (0, uuid_1.v4)();
exports.getUUID = getUUID;
const isValidUUID = (uuid) => (0, uuid_1.validate)(uuid);
exports.isValidUUID = isValidUUID;
const evaluateToBoolean = (...args) => [...args].every((e) => !!e);
const compact = (value, data) => (!!value ? data : {});
exports.compact = compact;
const getPreprocessorType = (processor) => {
    const processorGroup = Object.keys(types_1.EPreProcessorGroup);
    switch (processor) {
        case types_1.EPreProcessor.canny:
            return types_1.EPreProcessorGroup.canny;
        // break
        case types_1.EPreProcessor.depth_leres:
        case types_1.EPreProcessor.depth_midas:
        case types_1.EPreProcessor.depth_zoe:
            return types_1.EPreProcessorGroup.depth;
        // break
        case types_1.EPreProcessor.inpaint_global_harmonious:
            return types_1.EPreProcessorGroup.depth;
        // break
        case types_1.EPreProcessor.lineart_anime:
            return types_1.EPreProcessorGroup.lineart_anime;
        // break
        case types_1.EPreProcessor.lineart_coarse:
        case types_1.EPreProcessor.lineart_realistic:
        case types_1.EPreProcessor.lineart_standard:
            return types_1.EPreProcessorGroup.lineart;
        // break
        case types_1.EPreProcessor.mlsd:
            return types_1.EPreProcessorGroup.mlsd;
        // break
        case types_1.EPreProcessor.normal_bae:
            return types_1.EPreProcessorGroup.normalbae;
        // break
        case types_1.EPreProcessor.openpose_face:
        case types_1.EPreProcessor.openpose_faceonly:
        case types_1.EPreProcessor.openpose_full:
        case types_1.EPreProcessor.openpose_hand:
        case types_1.EPreProcessor.openpose:
            return types_1.EPreProcessorGroup.openpose;
        // break
        case types_1.EPreProcessor.scribble_hed:
        case types_1.EPreProcessor.scribble_pidinet:
            return types_1.EPreProcessorGroup.scribble;
        // break
        case types_1.EPreProcessor.seg_ofade20k:
        case types_1.EPreProcessor.seg_ofcoco:
        case types_1.EPreProcessor.seg_ufade20k:
            return types_1.EPreProcessorGroup.seg;
        // break
        case types_1.EPreProcessor.shuffle:
            return types_1.EPreProcessorGroup.shuffle;
        // break
        case types_1.EPreProcessor.softedge_hed:
        case types_1.EPreProcessor.softedge_hedsafe:
        case types_1.EPreProcessor.softedge_pidinet:
        case types_1.EPreProcessor.softedge_pidisafe:
            return types_1.EPreProcessorGroup.softedge;
        // break
        case types_1.EPreProcessor.tile_gaussian:
            return types_1.EPreProcessorGroup.tile;
        // break
        default:
            return types_1.EPreProcessorGroup.canny;
    }
};
exports.getPreprocessorType = getPreprocessorType;
const accessDeepObject = ({ key, data, useZero = true, shouldReturnString = false, }) => {
    const splittedKeys = key.split(/\.|\[/).map((key) => key.replace(/\]$/, ""));
    const value = splittedKeys.reduce((acc, curr) => {
        var _a, _b;
        const returnZero = useZero ? 0 : undefined;
        const currentValue = acc === null || acc === void 0 ? void 0 : acc[curr];
        if (!currentValue) {
            return returnZero;
        }
        if (Array.isArray(currentValue) && /^\d+$/.test(curr)) {
            const index = parseInt(curr, 10);
            if (index >= 0 && index < currentValue.length) {
                return (acc[curr] = currentValue[index]);
            }
            else {
                return (_a = acc[curr]) !== null && _a !== void 0 ? _a : returnZero;
            }
        }
        else {
            return (_b = acc[curr]) !== null && _b !== void 0 ? _b : returnZero;
        }
    }, data || {});
    // if (typeof value === "object" && shouldReturnString) {
    //   return JSON.stringify(value);
    // }
    return value !== null && value !== void 0 ? value : {};
};
exports.accessDeepObject = accessDeepObject;
const delay = (time, milliseconds = 1000) => {
    return new Promise((resolve) => setTimeout(resolve, time * milliseconds));
};
exports.delay = delay;
class MockFile {
    constructor() {
        this.create = function (name, size, mimeType) {
            name = name || "mock.txt";
            size = size || 1024;
            mimeType = mimeType || "plain/txt";
            var blob = new Blob([range(size)], { type: mimeType });
            blob.lastModifiedDate = new Date();
            blob.name = name;
            return blob;
        };
    }
}
exports.MockFile = MockFile;
function range(count) {
    var output = "";
    for (var i = 0; i < count; i++) {
        output += "a";
    }
    return output;
}
exports.RETRY_SDK_COUNTS = {
    GLOBAL: 2,
    REQUEST_IMAGES: 2,
};
const remove1Mutate = (col, targetElem) => {
    if (col == null) {
        return;
    }
    let i = col.indexOf(targetElem);
    if (i === -1) {
        return;
    }
    col.splice(i, 1);
};
exports.remove1Mutate = remove1Mutate;
const removeListener = (listeners, listener) => {
    return listeners.filter((lis) => lis.key !== listener.key);
};
exports.removeListener = removeListener;
const removeAllKeyListener = ({ listeners, key, }) => {
    return listeners.filter((lis) => (lis === null || lis === void 0 ? void 0 : lis.key) !== key);
};
exports.removeAllKeyListener = removeAllKeyListener;
var LISTEN_TO_IMAGES_KEY;
(function (LISTEN_TO_IMAGES_KEY) {
    LISTEN_TO_IMAGES_KEY["REQUEST_IMAGES"] = "REQUEST_IMAGES";
})(LISTEN_TO_IMAGES_KEY || (exports.LISTEN_TO_IMAGES_KEY = LISTEN_TO_IMAGES_KEY = {}));
const evaluateNonTrue = ({ key, value, }) => {
    if (!!value || value === 0 || value === false) {
        return { [key]: value };
    }
    else {
        return {};
    }
};
exports.evaluateNonTrue = evaluateNonTrue;
