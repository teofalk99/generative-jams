"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunwareServer = void 0;
// @ts-ignore
// import ReconnectingWebsocket from "./reconnect";
const ws_1 = __importDefault(require("ws"));
const Runware_base_1 = require("./Runware-base");
const types_1 = require("./types");
// let allImages: IImage[] = [];
class RunwareServer extends Runware_base_1.RunwareBase {
    constructor({ apiKey, url }) {
        super({ apiKey, url });
        this._instantiated = false;
        this._listeners = [];
        this._reconnectingIntervalId = null;
        this.send = (msg) => {
            this._ws.send(JSON.stringify([msg]));
        };
        this._sdkType = types_1.SdkType.SERVER;
        if (apiKey) {
            this.connect();
        }
    }
    // protected addListener({
    //   lis,
    //   check,
    //   groupKey,
    // }: {
    //   lis: (v: any) => any;
    //   check: (v: any) => any;
    //   groupKey?: string;
    // }) {
    //   const listener = (msg: any) => {
    //     if (msg?.error) {
    //       lis(msg);
    //     } else if (check(msg)) {
    //       lis(msg);
    //     }
    //   };
    //   const groupListener = { key: getUUID(), listener, groupKey };
    //   this._listeners.push(groupListener);
    //   const destroy = () => {
    //     this._listeners = removeListener(this._listeners, groupListener);
    //   };
    //   return {
    //     destroy,
    //   };
    // }
    async connect() {
        if (!this._url)
            return;
        this._ws = new ws_1.default(this._url, {
            perMessageDeflate: false,
        });
        // delay(1);
        this._ws.on("error", () => { });
        this._ws.on("close", () => {
            this.handleClose();
        });
        this._ws.on("open", () => {
            if (this._reconnectingIntervalId) {
                clearInterval(this._reconnectingIntervalId);
            }
            if (this._connectionSessionUUID && this.isWebsocketReadyState()) {
                this.send({
                    taskType: types_1.ETaskType.AUTHENTICATION,
                    apiKey: this._apiKey,
                    connectionSessionUUID: this._connectionSessionUUID,
                });
            }
            else {
                if (this.isWebsocketReadyState()) {
                    this.send({
                        apiKey: this._apiKey,
                        taskType: types_1.ETaskType.AUTHENTICATION,
                    });
                }
            }
            this.addListener({
                taskUUID: types_1.ETaskType.AUTHENTICATION,
                lis: (m) => {
                    var _a, _b;
                    if (m === null || m === void 0 ? void 0 : m.error) {
                        this._invalidAPIkey = "Invalid API key";
                        return;
                    }
                    this._connectionSessionUUID =
                        (_b = (_a = m === null || m === void 0 ? void 0 : m[types_1.ETaskType.AUTHENTICATION]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.connectionSessionUUID;
                    this._invalidAPIkey = undefined;
                },
            });
            // this.addListener({
            //   check: (m) => m?.newConnectionSessionUUID?.connectionSessionUUID,
            //   lis: (m) => {
            //     if (m?.error) {
            //       if (m.errorId === 19) {
            //         this._invalidAPIkey = "Invalid API key";
            //       } else {
            //         this._invalidAPIkey = "Error connection ";
            //       }
            //       return;
            //     }
            //     this._connectionSessionUUID =
            //       m?.newConnectionSessionUUID?.connectionSessionUUID;
            //     this._invalidAPIkey = undefined;
            //     this.heartBeat();
            //   },
            // });
            // this._pongListener?.destroy();
            // this._pongListener = this.addListener({
            //   check: (m) => m?.pong,
            //   lis: (m) => {
            //     // console.log({ m });
            //     if (m.pong) {
            //       this.heartBeat();
            //     }
            //   },
            // });
        });
        this._ws.on("message", (e, isBinary) => {
            const data = isBinary ? e : e === null || e === void 0 ? void 0 : e.toString();
            if (!data)
                return;
            const m = JSON.parse(data);
            this._listeners.forEach((lis) => {
                const result = lis.listener(m);
                if (result) {
                    return;
                }
            });
        });
    }
    handleClose() {
        if (this._invalidAPIkey) {
            console.error(this._invalidAPIkey);
            return;
        }
        if (this._reconnectingIntervalId) {
            clearInterval(this._reconnectingIntervalId);
        }
        // this._reconnectingIntervalId = setInterval(() => this.connect(), 1000);
    }
    heartBeat() {
        clearTimeout(this._pingTimeout);
        this._pingTimeout = setTimeout(() => {
            if (this.isWebsocketReadyState()) {
                this.send({ ping: true });
            }
        }, 5000);
    }
}
exports.RunwareServer = RunwareServer;
